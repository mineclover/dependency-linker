#!/usr/bin/env node

/**
 * ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ê´€ë¦¬ CLI ëª…ë ¹
 * Database Schema Management CLI Commands
 */

import { Command } from 'commander';
import { getServiceContainer } from '../../infrastructure/container/ServiceContainer';
import { NotionApiService } from '../../infrastructure/notion/core/NotionApiService.js';
import { NotionClientFactory } from '../../infrastructure/notion/core/NotionClientFactory.js';
import { DatabaseAccessValidationService } from '../../services/validation/DatabaseAccessValidationService';
import type { ConfigurationService } from '../../services/config/ConfigurationService';
import { DatabaseSchemaManager } from '../../infrastructure/notion/DatabaseSchemaManager.js';
import { logger } from '../../shared/utils/index.js';
import { MigrationOrchestrator } from '../../services/notion/MigrationOrchestrator.js';
import { NotionDatabaseCreator } from '../../services/notion/NotionDatabaseCreator.js';

/**
 * Helper function to get NotionApiService with configuration
 */
async function getNotionService(): Promise<NotionApiService> {
  const container = getServiceContainer();
  const configService = container.resolve<ConfigurationService>('configurationService');
  const config = await configService.loadAndProcessConfig(process.cwd());
  
  if (!config.apiKey) {
    throw new Error('Notion API key not found in configuration');
  }

  const clientInstance = NotionClientFactory.createClient({
    apiKey: config.apiKey,
    parentPageId: config.parentPageId,
    projectPath: config.projectPath
  });

  return new NotionApiService(clientInstance);
}

/**
 * Helper function to get schema manager
 */
async function getSchemaManager(): Promise<DatabaseSchemaManager> {
  return new DatabaseSchemaManager(process.cwd());
}

// ê¸°ë³¸ ìŠ¤í‚¤ë§ˆ ì •ì˜ (í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€)
const DEFAULT_SCHEMAS = {
  files: {
    "Language": {
      type: "select",
      select: {
        options: [
          { name: "TypeScript", color: "blue" },
          { name: "JavaScript", color: "yellow" },
          { name: "Python", color: "green" },
          { name: "Go", color: "purple" },
          { name: "Rust", color: "red" },
          { name: "Other", color: "gray" }
        ]
      }
    },
    "Dependencies Count": { type: "number", number: {} },
    "Local Dependencies Count": { type: "number", number: {} },
    "Library Dependencies Count": { type: "number", number: {} },
    "Functions Count": { type: "number", number: {} },
    "Classes Count": { type: "number", number: {} },
    "Analysis Time": { type: "rich_text", rich_text: {} },
    "Status": {
      type: "select",
      select: {
        options: [
          { name: "Uploaded", color: "green" },
          { name: "Updated", color: "blue" },
          { name: "Error", color: "red" }
        ]
      }
    }
  },
  
  functions: {
    "File Path": { type: "rich_text", rich_text: {} },
    "Language": {
      type: "select",
      select: {
        options: [
          { name: "TypeScript", color: "blue" },
          { name: "JavaScript", color: "yellow" },
          { name: "Python", color: "green" },
          { name: "Go", color: "purple" },
          { name: "Rust", color: "red" }
        ]
      }
    },
    "Line Number": { type: "number", number: {} },
    "Parameters Count": { type: "number", number: {} },
    "Return Type": { type: "rich_text", rich_text: {} },
    "Is Async": { type: "checkbox", checkbox: {} },
    "Is Exported": { type: "checkbox", checkbox: {} },
    "Complexity": {
      type: "select",
      select: {
        options: [
          { name: "Low", color: "green" },
          { name: "Medium", color: "yellow" },
          { name: "High", color: "red" }
        ]
      }
    },
    "Description": { type: "rich_text", rich_text: {} },
    "Project": {
      type: "select",
      select: {
        options: [{ name: "dependency-linker", color: "blue" }]
      }
    }
  },

  dependencies: {
    "File Path": { type: "rich_text", rich_text: {} },
    "Language": {
      type: "select",
      select: {
        options: [
          { name: "TypeScript", color: "blue" },
          { name: "JavaScript", color: "yellow" },
          { name: "Python", color: "green" },
          { name: "Go", color: "purple" },
          { name: "Rust", color: "red" }
        ]
      }
    },
    "Type": {
      type: "select",
      select: {
        options: [
          { name: "Local", color: "blue" },
          { name: "Library", color: "green" },
          { name: "Built-in", color: "gray" }
        ]
      }
    },
    "Import Statement": { type: "rich_text", rich_text: {} },
    "Line Number": { type: "number", number: {} },
    "Project": {
      type: "select",
      select: {
        options: [{ name: "dependency-linker", color: "blue" }]
      }
    }
  },

  libraries: {
    "Version": { type: "rich_text", rich_text: {} },
    "Package Manager": {
      type: "select",
      select: {
        options: [
          { name: "npm", color: "red" },
          { name: "yarn", color: "blue" },
          { name: "pnpm", color: "orange" },
          { name: "bun", color: "yellow" },
          { name: "pip", color: "green" },
          { name: "cargo", color: "orange" },
          { name: "go mod", color: "blue" }
        ]
      }
    },
    "Category": {
      type: "select",
      select: {
        options: [
          { name: "Framework", color: "purple" },
          { name: "Library", color: "blue" },
          { name: "Utility", color: "green" },
          { name: "Dev Tool", color: "orange" },
          { name: "Testing", color: "yellow" },
          { name: "Build Tool", color: "red" }
        ]
      }
    },
    "Language": {
      type: "select",
      select: {
        options: [
          { name: "TypeScript", color: "blue" },
          { name: "JavaScript", color: "yellow" },
          { name: "Python", color: "green" },
          { name: "Go", color: "purple" },
          { name: "Rust", color: "red" }
        ]
      }
    },
    "Is Dev Dependency": { type: "checkbox", checkbox: {} },
    "Description": { type: "rich_text", rich_text: {} },
    "Project": {
      type: "select",
      select: {
        options: [{ name: "dependency-linker", color: "blue" }]
      }
    }
  },

  classes: {
    "File Path": { type: "rich_text", rich_text: {} },
    "Language": {
      type: "select",
      select: {
        options: [
          { name: "TypeScript", color: "blue" },
          { name: "JavaScript", color: "yellow" },
          { name: "Python", color: "green" },
          { name: "Go", color: "purple" },
          { name: "Rust", color: "red" }
        ]
      }
    },
    "Line Number": { type: "number", number: {} },
    "Methods Count": { type: "number", number: {} },
    "Properties Count": { type: "number", number: {} },
    "Is Exported": { type: "checkbox", checkbox: {} },
    "Is Abstract": { type: "checkbox", checkbox: {} },
    "Extends": { type: "rich_text", rich_text: {} },
    "Implements": { type: "rich_text", rich_text: {} },
    "Description": { type: "rich_text", rich_text: {} },
    "Project": {
      type: "select",
      select: {
        options: [{ name: "dependency-linker", color: "blue" }]
      }
    }
  }
};

/**
 * Helper function to get configuration service and load config
 */
async function getConfigService() {
  const container = getServiceContainer();
  const configService = container.resolve<ConfigurationService>('configurationService');
  const config = await configService.loadAndProcessConfig(process.cwd());
  return { configService, config };
}

const program = new Command();

program
  .name('deplink-db')
  .description('ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ê´€ë¦¬ ë„êµ¬')
  .version('1.0.0');

// ìŠ¤í‚¤ë§ˆ ì´ˆê¸°í™” ëª…ë ¹ (JSON íŒŒì¼ ê¸°ë°˜)
program
  .command('init')
  .description('JSON íŒŒì¼ì˜ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸°í™”í•©ë‹ˆë‹¤')
  .option('-d, --database <name>', 'íŠ¹ì • ë°ì´í„°ë² ì´ìŠ¤ë§Œ ì´ˆê¸°í™” (files, functions, dependencies, libraries, classes, relationships)')
  .option('-f, --force', 'ê¸°ì¡´ ì†ì„±ì„ ê°•ì œë¡œ ë®ì–´ì”ë‹ˆë‹¤')
  .option('--force-recreate', 'Force ì˜µì…˜: ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì™„ì „íˆ ì¬ìƒì„±í•©ë‹ˆë‹¤ (ëª¨ë“  ë°ì´í„° ì‚­ì œ ì£¼ì˜!)')
  .action(async (options) => {
    console.log('ğŸ—ï¸ JSON ìŠ¤í‚¤ë§ˆ ê¸°ë°˜ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...');
    
    try {
      const { config } = await getConfigService();
      const schemaManager = await getSchemaManager();
      const schemas = await schemaManager.loadSchemas();
      
      const databases = options.database ? [options.database] : Object.keys(schemas.databases);
      
      for (const dbName of databases) {
        if (!schemas.databases[dbName]) {
          console.log(`âŒ JSON íŒŒì¼ì—ì„œ ${dbName} ìŠ¤í‚¤ë§ˆë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
          continue;
        }

        const dbId = config.databases[dbName as keyof typeof config.databases];
        if (!dbId) {
          console.log(`âŒ ${dbName} ë°ì´í„°ë² ì´ìŠ¤ IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
          continue;
        }

        console.log(`ğŸ”„ ${dbName} ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆë¥¼ ì—…ë°ì´íŠ¸ ì¤‘...`);
        console.log(`ğŸ“‹ JSON ìŠ¤í‚¤ë§ˆ: ${Object.keys(schemas.databases[dbName].initial_data_source?.properties || {}).length}ê°œ ì†ì„±`);
        
        const notionSchema = await schemaManager.getDatabaseSchema(dbName);
        
        try {
          if (options.forceRecreate) {
            console.log(`ğŸš¨ Force ëª¨ë“œ: ${dbName} ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì¬ìƒì„±í•©ë‹ˆë‹¤...`);
            await handleForceRecreate(dbName, dbId, schemas.databases[dbName], config);
          } else {
            const notionService = await getNotionService();
            const result = await notionService.updateDatabase(dbId, {
              properties: notionSchema.properties
            });
            
            if (result.success) {
              console.log(`âœ… ${dbName} ìŠ¤í‚¤ë§ˆ ì—…ë°ì´íŠ¸ ì™„ë£Œ (${Object.keys(notionSchema.properties).length}ê°œ ì†ì„±)`);
            } else {
              console.log(`âŒ ${dbName} ìŠ¤í‚¤ë§ˆ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${result.error?.message}`);
            }
          }
        } catch (error: any) {
          if (error.message.includes("Can't edit block that is archived")) {
            console.log(`ğŸ“¦ ${dbName} ë°ì´í„°ë² ì´ìŠ¤ê°€ ì•„ì¹´ì´ë¸Œ ìƒíƒœì…ë‹ˆë‹¤.`);
            console.log(`ğŸ”— ë³µêµ¬í•˜ë ¤ë©´ ë‹¤ìŒ ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ Notionì—ì„œ ë³µì›í•˜ì„¸ìš”:`);
            console.log(`   https://notion.so/${dbId.replace(/-/g, '')}`);
            console.log(`ğŸ’¡ ë³µì› í›„ ë‹¤ì‹œ ì‹¤í–‰í•´ì£¼ì„¸ìš”: bun run db:init -d ${dbName}`);
          } else {
            console.log(`âŒ ${dbName} ìŠ¤í‚¤ë§ˆ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${error.message}`);
          }
        }
      }
      
      console.log('\nğŸ‰ JSON ìŠ¤í‚¤ë§ˆ ê¸°ë°˜ ì´ˆê¸°í™” ì™„ë£Œ!');
    } catch (error: any) {
      console.error(`ğŸ’¥ ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`);
      process.exit(1);
    }
  });

/**
 * Force ì˜µì…˜: ë°ì´í„°ë² ì´ìŠ¤ ì™„ì „ ì¬ìƒì„±
 * ê¸°ì¡´ ë°ì´í„°ë² ì´ìŠ¤ì˜ ëª¨ë“  í˜ì´ì§€ë¥¼ ì‚­ì œí•˜ê³  ìƒˆë¡œìš´ ìŠ¤í‚¤ë§ˆë¡œ ì¬ìƒì„±
 */
async function handleForceRecreate(
  dbName: string, 
  dbId: string, 
  dbSchema: any, 
  config: any
): Promise<void> {
  console.log(`ğŸš¨ ì£¼ì˜: ${dbName} ë°ì´í„°ë² ì´ìŠ¤ì˜ ëª¨ë“  ë°ì´í„°ê°€ ì‚­ì œë©ë‹ˆë‹¤!`);
  console.log('â³ 5ì´ˆ í›„ ì§„í–‰ë©ë‹ˆë‹¤. ì¤‘ë‹¨í•˜ë ¤ë©´ Ctrl+Cë¥¼ ëˆ„ë¥´ì„¸ìš”...');
  
  // 5ì´ˆ ëŒ€ê¸°
  await new Promise(resolve => setTimeout(resolve, 5000));
  
  try {
    const notionService = await getNotionService();
    const creator = new NotionDatabaseCreator(notionService);
    const orchestrator = new MigrationOrchestrator(notionService, process.cwd());
    
    // 1. ê¸°ì¡´ ë°ì´í„°ë² ì´ìŠ¤ì˜ ëª¨ë“  í˜ì´ì§€ ì¡°íšŒ
    console.log('ğŸ” ê¸°ì¡´ ë°ì´í„°ë² ì´ìŠ¤ í˜ì´ì§€ ì¡°íšŒ ì¤‘...');
    const pagesResult = await notionService.queryDatabase(dbId, {});
    
    if (pagesResult.success && pagesResult.data.results.length > 0) {
      console.log(`ğŸ“„ ${pagesResult.data.results.length}ê°œ í˜ì´ì§€ ë°œê²¬, ì‚­ì œ ì¤‘...`);
      
      // 2. ëª¨ë“  í˜ì´ì§€ ì‚­ì œ
      for (const page of pagesResult.data.results) {
        try {
          await notionService.updatePage(page.id, { archived: true });
          console.log(`ğŸ—‘ï¸ í˜ì´ì§€ ì‚­ì œ: ${page.id}`);
        } catch (error) {
          console.log(`âš ï¸ í˜ì´ì§€ ì‚­ì œ ì‹¤íŒ¨: ${page.id} - ${error}`);
        }
      }
    }
    
    // 3. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì™„ì „ ì´ˆê¸°í™”
    console.log('ğŸ”§ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì¬ìƒì„± ì¤‘...');
    const result = await creator.createDatabase({
      schema: dbSchema,
      parentPageId: config.parentPageId,
      options: {
        cleanupExisting: true,
        description: `Force recreated ${dbName} database with complete schema`
      }
    });
    
    if (result.success) {
      console.log(`âœ… ${dbName} ë°ì´í„°ë² ì´ìŠ¤ ì¬ìƒì„± ì™„ë£Œ`);
      console.log(`ğŸ†” ìƒˆ ë°ì´í„°ë² ì´ìŠ¤ ID: ${result.databaseId}`);
      console.log(`ğŸ”— URL: ${result.databaseUrl}`);
      console.log(`\nğŸ’¡ ìƒˆ ë°ì´í„°ë² ì´ìŠ¤ IDë¥¼ ì„¤ì • íŒŒì¼ì— ì—…ë°ì´íŠ¸í•˜ì„¸ìš”:`);
      console.log(`   databases.${dbName}: "${result.databaseId}"`);
    } else {
      console.log(`âŒ ë°ì´í„°ë² ì´ìŠ¤ ì¬ìƒì„± ì‹¤íŒ¨: ${result.message}`);
      if (result.errors) {
        result.errors.forEach(error => console.log(`   - ${error}`));
      }
    }
    
  } catch (error: any) {
    console.error(`ğŸ’¥ Force ì¬ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    throw error;
  }
}

// ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ ë° ìŠ¤í‚¤ë§ˆ í™•ì¸ ëª…ë ¹ (status ê¸°ëŠ¥ í†µí•©)
program
  .command('check')
  .description('ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìƒíƒœ, ìŠ¤í‚¤ë§ˆ ë° Notion ë§í¬ë¥¼ í™•ì¸í•©ë‹ˆë‹¤')
  .option('-d, --database <name>', 'íŠ¹ì • ë°ì´í„°ë² ì´ìŠ¤ë§Œ í™•ì¸')
  .option('--links-only', 'ë§í¬ë§Œ ì¶œë ¥ (ìƒì„¸ ì •ë³´ ì œì™¸)')
  .action(async (options) => {
    if (options.linksOnly) {
      console.log('ğŸ”— Notion ë°ì´í„°ë² ì´ìŠ¤ ë§í¬:\n');
    } else {
      console.log('ğŸ“Š ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìƒíƒœ ë° ìŠ¤í‚¤ë§ˆ í™•ì¸:\n');
    }
    
    try {
      // ì„¤ì •ì„ ë¨¼ì € ë¡œë“œ
      const { config } = await getConfigService();
      // Notion ì„œë¹„ìŠ¤ë„ í•œ ë²ˆë§Œ ë¡œë“œ
      const notionService = await getNotionService();
      const workspaceUrl = 'https://notion.so';
      
      const allDatabases = [
        { name: 'files', title: 'FILES (Project Files)', icon: 'ğŸ“' },
        { name: 'functions', title: 'FUNCTIONS (dependency-linker - Functions)', icon: 'âš™ï¸' },
        { name: 'dependencies', title: 'DEPENDENCIES (Dependency Tracker - Dependencies)', icon: 'ğŸ“¦' },
        { name: 'libraries', title: 'LIBRARIES (Dependency Tracker - Libraries)', icon: 'ğŸ“š' },
        { name: 'classes', title: 'CLASSES (Dependency Tracker - Classes)', icon: 'ğŸ—ï¸' },
        { name: 'relationships', title: 'RELATIONSHIPS (Dependency Tracker - Relationships)', icon: 'ğŸ”„' }
      ];
      
      const databases = options.database 
        ? allDatabases.filter(db => db.name === options.database)
        : allDatabases;
      
      if (databases.length === 0) {
        console.log(`âŒ ë°ì´í„°ë² ì´ìŠ¤ '${options.database}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        process.exit(0);
      }
      
      for (const db of databases) {
        const dbId = config.databases[db.name as keyof typeof config.databases];
        
        if (!dbId) {
          console.log(`âšª ${db.icon} ${db.title}`);
          console.log('   ìƒíƒœ: ì„¤ì •ë˜ì§€ ì•ŠìŒ');
          console.log('');
          continue;
        }

        try {
          const result = await notionService.retrieveDatabase(dbId);
          
          if (!result.success) {
            throw new Error(result.error?.message || 'Failed to retrieve database');
          }
          
          const database = result.data;
          
          if (options.linksOnly) {
            console.log(`${workspaceUrl}/${dbId.replace(/-/g, '')}`);
          } else {
            console.log(`âœ… ${db.icon} ${db.title}`);
            console.log(`   ë§í¬: ${workspaceUrl}/${dbId.replace(/-/g, '')}`);
            console.log(`   ì œëª©: ${'title' in database ? database.title?.[0]?.plain_text || 'Untitled' : 'Untitled'}`);
            console.log(`   ìƒíƒœ: ì—°ê²°ë¨`);
            
            
            // ì†ì„± ì •ë³´ëŠ” data sources APIë¥¼ í†µí•´ ê°€ì ¸ì˜¤ê¸° (2025-09-03 ìŠ¤í™)
            try {
              let properties: string[] = [];
              
              // ìƒˆë¡œìš´ API ìŠ¤í™: data_sources ë°°ì—´ì„ í™•ì¸
              if ('data_sources' in database && database.data_sources && database.data_sources.length > 0) {
                console.log(`   Data Sources: ${database.data_sources.length}ê°œ`);
                
                // ì²« ë²ˆì§¸ data sourceì˜ ì •ë³´ ì¶œë ¥
                const dataSource = database.data_sources[0];
                console.log(`   Data Source: ${dataSource.name || dataSource.id}`);
                
                // ê¸°ì¡´ ìŠ¤í‚¤ë§ˆ ê´€ë¦¬ìë¥¼ ì‚¬ìš©í•´ì„œ ìŠ¤í‚¤ë§ˆ ì¡°íšŒ
                try {
                  const schemaManager = new DatabaseSchemaManager('.');
                  const databaseSchema = await schemaManager.getDatabaseSchema(db.name);
                  
                  if (databaseSchema && databaseSchema.properties) {
                    properties = Object.keys(databaseSchema.properties);
                    const otherProperties = properties.filter(key => key !== 'Name');
                    console.log(`   ì†ì„± ìˆ˜: ${properties.length} (ìŠ¤í‚¤ë§ˆ íŒŒì¼ì—ì„œ)`);
                    
                    if (otherProperties.length > 0) {
                      console.log('   ì†ì„± ëª©ë¡:');
                      otherProperties.slice(0, 5).forEach(prop => {
                        console.log(`     - ${prop}`);
                      });
                      if (otherProperties.length > 5) {
                        console.log(`     ... ë° ${otherProperties.length - 5}ê°œ ë”`);
                      }
                    } else {
                      console.log('   ì†ì„±: Nameë§Œ ìˆìŒ');
                    }
                  } else {
                    console.log('   ì†ì„±: ìŠ¤í‚¤ë§ˆ ì •ì˜ ì—†ìŒ');
                  }
                } catch (schemaError: any) {
                  console.log(`   ì†ì„±: ìŠ¤í‚¤ë§ˆ ì¡°íšŒ ì‹¤íŒ¨ (${schemaError.message})`);
                }
              } 
              // ì´ì „ API ìŠ¤í™ í˜¸í™˜ì„±: propertiesë¥¼ ì§ì ‘ í™•ì¸
              else if ('properties' in database && database.properties) {
                properties = Object.keys(database.properties);
                const otherProperties = properties.filter(key => key !== 'Name');
                console.log(`   ì†ì„± ìˆ˜: ${properties.length} (ì´ì „ API ìŠ¤í™)`);
                
                if (otherProperties.length > 0) {
                  console.log('   ì†ì„± ëª©ë¡:');
                  otherProperties.slice(0, 5).forEach(prop => {
                    console.log(`     - ${prop}`);
                  });
                  if (otherProperties.length > 5) {
                    console.log(`     ... ë° ${otherProperties.length - 5}ê°œ ë”`);
                  }
                } else {
                  console.log('   ì†ì„±: Nameë§Œ ìˆìŒ');
                }
              } else {
                console.log('   ì†ì„±: ìŠ¤í‚¤ë§ˆ ì •ë³´ ì—†ìŒ');
              }
            } catch (schemaError: any) {
              console.log(`   ì†ì„±: ìŠ¤í‚¤ë§ˆ ì¡°íšŒ ì‹¤íŒ¨ (${schemaError.message})`);
            }
            
            console.log('');
          }
          
        } catch (error: any) {
          if (options.linksOnly) {
            console.log(`${workspaceUrl}/${dbId.replace(/-/g, '')} # ì˜¤ë¥˜: ${error.message}`);
          } else {
            if (error.message.includes("archived") || error.message.includes("Can't edit block that is archived")) {
              console.log(`ğŸ“¦ ${db.icon} ${db.title} (ì•„ì¹´ì´ë¸Œë¨)`);
              console.log(`   ë§í¬: ${workspaceUrl}/${dbId.replace(/-/g, '')}`);
              console.log(`   ìƒíƒœ: ì•„ì¹´ì´ë¸Œë¨ - ë³µì› í•„ìš”`);
              console.log(`   ğŸ’¡ ë§í¬ì—ì„œ "Restore" ë²„íŠ¼ í´ë¦­í•˜ì—¬ ë³µì›í•˜ì„¸ìš”`);
            } else {
              console.log(`âŒ ${db.icon} ${db.title}`);
              console.log(`   ë§í¬: ${workspaceUrl}/${dbId.replace(/-/g, '')}`);
              console.log(`   ì˜¤ë¥˜: ${error.message}`);
            }
            console.log('');
          }
        }
      }
      
      // ë¶€ëª¨ í˜ì´ì§€ ë§í¬ (links-onlyê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ)
      if (!options.linksOnly && config.parentPageId) {
        console.log(`ğŸ  Parent Page (All Databases Container):`);
        console.log(`   ${workspaceUrl}/${config.parentPageId.replace(/-/g, '')}`);
        console.log('');
      }
      
      if (!options.linksOnly) {
        console.log('ğŸ’¡ ê° ë§í¬ë¥¼ í´ë¦­í•˜ë©´ í•´ë‹¹ ë°ì´í„°ë² ì´ìŠ¤ë¡œ ì§ì ‘ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
        console.log('ğŸ’¡ --links-only ì˜µì…˜ìœ¼ë¡œ ë§í¬ë§Œ ê°„ë‹¨íˆ ì¶œë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
      } else if (config.parentPageId) {
        console.log(`${workspaceUrl}/${config.parentPageId.replace(/-/g, '')}`);
      }
      
      // ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ë©´ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
      process.exit(0);
      
    } catch (error: any) {
      console.error(`ğŸ’¥ í™•ì¸ ì‹¤íŒ¨: ${error.message}`);
      process.exit(1);
    }
  });


// ì†ì„± ì¶”ê°€ ëª…ë ¹
program
  .command('add-property')
  .description('ë°ì´í„°ë² ì´ìŠ¤ì— ìƒˆ ì†ì„±ì„ ì¶”ê°€í•©ë‹ˆë‹¤')
  .requiredOption('-d, --database <name>', 'ë°ì´í„°ë² ì´ìŠ¤ ì´ë¦„ (files, functions, dependencies, libraries, classes)')
  .requiredOption('-n, --name <name>', 'ì†ì„± ì´ë¦„')
  .requiredOption('-t, --type <type>', 'ì†ì„± íƒ€ì… (text, number, select, checkbox, date)')
  .option('-o, --options <options>', 'select íƒ€ì…ì˜ ê²½ìš° ì˜µì…˜ë“¤ (ì‰¼í‘œë¡œ êµ¬ë¶„)')
  .action(async (options) => {
    console.log(`ğŸ”§ ${options.database}ì— "${options.name}" ì†ì„±ì„ ì¶”ê°€í•©ë‹ˆë‹¤...`);
    
    try {
      const { config } = await getConfigService();
      const dbId = config.databases[options.database as keyof typeof config.databases];
      if (!dbId) {
        console.log(`âŒ ${options.database} ë°ì´í„°ë² ì´ìŠ¤ IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
        process.exit(1);
      }

      let propertyConfig: any = {};
      
      switch (options.type) {
        case 'text':
          propertyConfig = { type: "rich_text", rich_text: {} };
          break;
        case 'number':
          propertyConfig = { type: "number", number: {} };
          break;
        case 'checkbox':
          propertyConfig = { type: "checkbox", checkbox: {} };
          break;
        case 'date':
          propertyConfig = { type: "date", date: {} };
          break;
        case 'select':
          if (!options.options) {
            console.log('âŒ select íƒ€ì…ì—ëŠ” --optionsê°€ í•„ìš”í•©ë‹ˆë‹¤.');
            process.exit(1);
          }
          const selectOptions = options.options.split(',').map((opt: string, index: number) => ({
            name: opt.trim(),
            color: ['blue', 'green', 'yellow', 'red', 'purple', 'orange'][index % 6]
          }));
          propertyConfig = {
            type: "select",
            select: { options: selectOptions }
          };
          break;
        default:
          console.log(`âŒ ì§€ì›ë˜ì§€ ì•ŠëŠ” ì†ì„± íƒ€ì…: ${options.type}`);
          process.exit(1);
      }

      const properties = { [options.name]: propertyConfig };
      await notionClient.updateDatabaseSchema(dbId, properties);
      console.log(`âœ… "${options.name}" ì†ì„± ì¶”ê°€ ì™„ë£Œ!`);
    } catch (error: any) {
      console.error(`ğŸ’¥ ì†ì„± ì¶”ê°€ ì‹¤íŒ¨: ${error.message}`);
      process.exit(1);
    }
  });

// í…ŒìŠ¤íŠ¸ ì—°ê²° ëª…ë ¹
program
  .command('test')
  .description('Notion ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤')
  .action(async () => {
    console.log('ğŸ”Œ Notion ì—°ê²°ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤...');
    
    try {
      const connected = await notionClient.testConnection();
      if (connected) {
        console.log('âœ… Notion ì—°ê²° ì„±ê³µ!');
        
        // ì„¤ì •ëœ ë°ì´í„°ë² ì´ìŠ¤ë“¤ í™•ì¸
        const databases = ['files', 'functions', 'dependencies', 'libraries', 'classes'];
        let configuredCount = 0;
        
        const { config } = await getConfigService();
        console.log('\nğŸ“Š ì„¤ì •ëœ ë°ì´í„°ë² ì´ìŠ¤:');
        for (const dbName of databases) {
          const dbId = config.databases[dbName as keyof typeof config.databases];
          if (dbId) {
            try {
              await notionClient.getDatabase(dbId);
              console.log(`   âœ… ${dbName}: ${dbId}`);
              configuredCount++;
            } catch (error: any) {
              if (error.message?.includes("archived") || error.message?.includes("Can't edit block that is archived")) {
                console.log(`   ğŸ“¦ ${dbName}: ${dbId} (ì•„ì¹´ì´ë¸Œë¨)`);
                console.log(`      ğŸ”— ë³µêµ¬: https://notion.so/${dbId.replace(/-/g, '')}`);
              } else {
                console.log(`   âŒ ${dbName}: ${dbId} (ì ‘ê·¼ ë¶ˆê°€)`);
              }
            }
          } else {
            console.log(`   âš ï¸  ${dbName}: ì„¤ì •ë˜ì§€ ì•ŠìŒ`);
          }
        }
        
        console.log(`\nğŸ¯ ${configuredCount}/5 ë°ì´í„°ë² ì´ìŠ¤ê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      } else {
        console.log('âŒ Notion ì—°ê²° ì‹¤íŒ¨');
        process.exit(1);
      }
    } catch (error: any) {
      console.error(`ğŸ’¥ ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${error.message}`);
      process.exit(1);
    }
  });

// ë³µì› ëª…ë ¹
program
  .command('restore')
  .description('ì•„ì¹´ì´ë¸Œëœ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ë³µì›í•©ë‹ˆë‹¤')
  .option('-d, --database <name>', 'íŠ¹ì • ë°ì´í„°ë² ì´ìŠ¤ë§Œ ë³µì›')
  .action(async (options) => {
    console.log('ğŸ”§ ì•„ì¹´ì´ë¸Œëœ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ í™•ì¸í•˜ê³  ë³µì› ê°€ì´ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤...\n');
    
    try {
      const { config } = await getConfigService();
      const databases = options.database ? [options.database] : ['files', 'functions', 'dependencies', 'libraries', 'classes'];
      let archivedDatabases = [];
      
      for (const dbName of databases) {
        const dbId = config.databases[dbName as keyof typeof config.databases];
        if (!dbId) {
          console.log(`âš ï¸ ${dbName}: ë°ì´í„°ë² ì´ìŠ¤ IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
          continue;
        }

        try {
          await notionClient.getDatabase(dbId);
          console.log(`âœ… ${dbName}: ì •ìƒ ìƒíƒœ`);
        } catch (error: any) {
          if (error.message?.includes("archived") || error.message?.includes("Can't edit block that is archived")) {
            archivedDatabases.push({ name: dbName, id: dbId });
            console.log(`ğŸ“¦ ${dbName}: ì•„ì¹´ì´ë¸Œ ìƒíƒœ`);
          } else {
            console.log(`âŒ ${dbName}: ì ‘ê·¼ ë¶ˆê°€ (${error.message})`);
          }
        }
      }
      
      if (archivedDatabases.length > 0) {
        console.log('\nğŸ”§ ì•„ì¹´ì´ë¸Œëœ ë°ì´í„°ë² ì´ìŠ¤ ë³µì› ê°€ì´ë“œ:');
        console.log('=====================================');
        
        for (const db of archivedDatabases) {
          console.log(`\nğŸ“¦ ${db.name.toUpperCase()}:`);
          console.log(`   ğŸ”— ë§í¬: https://notion.so/${db.id.replace(/-/g, '')}`);
          console.log(`   ğŸ“‹ ë³µì› ë°©ë²•:`);
          console.log(`      1. ìœ„ ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ Notion í˜ì´ì§€ë¡œ ì´ë™`);
          console.log(`      2. í˜ì´ì§€ ìš°ìƒë‹¨ì˜ "..." ë©”ë‰´ í´ë¦­`);
          console.log(`      3. "Restore" ë˜ëŠ” "ë³µì›" ë²„íŠ¼ í´ë¦­`);
          console.log(`      4. ë³µì› ì™„ë£Œ í›„: bun run db:init -d ${db.name}`);
        }
        
        console.log(`\nğŸ’¡ ëª¨ë“  ë°ì´í„°ë² ì´ìŠ¤ê°€ ë³µì›ë˜ë©´ ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ í™•ì¸:`);
        console.log(`   bun run db:check`);
      } else {
        console.log('\nğŸ‰ ëª¨ë“  ë°ì´í„°ë² ì´ìŠ¤ê°€ ì •ìƒ ìƒíƒœì…ë‹ˆë‹¤!');
      }
      
    } catch (error: any) {
      console.error(`ğŸ’¥ ë³µì› í™•ì¸ ì‹¤íŒ¨: ${error.message}`);
      process.exit(1);
    }
  });

// ìŠ¤í‚¤ë§ˆ ë¦¬ì…‹ ëª…ë ¹
program
  .command('reset')
  .description('ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆë¥¼ ì™„ì „íˆ ì´ˆê¸°í™”í•©ë‹ˆë‹¤ (ì£¼ì˜: ê¸°ì¡´ ì†ì„± ì‚­ì œ)')
  .option('-d, --database <name>', 'íŠ¹ì • ë°ì´í„°ë² ì´ìŠ¤ë§Œ ë¦¬ì…‹')
  .option('-y, --yes', 'í™•ì¸ ì—†ì´ ì‹¤í–‰')
  .action(async (options) => {
    if (!options.yes) {
      console.log('âš ï¸  ê²½ê³ : ì´ ëª…ë ¹ì€ ê¸°ì¡´ ì†ì„±ë“¤ì„ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
      console.log('ê³„ì†í•˜ë ¤ë©´ --yes í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.');
      process.exit(1);
    }

    console.log('ğŸ”„ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆë¥¼ ë¦¬ì…‹í•©ë‹ˆë‹¤...');
    
    try {
      const { config } = await getConfigService();
      const databases = options.database ? [options.database] : Object.keys(DEFAULT_SCHEMAS);
      
      for (const dbName of databases) {
        if (!DEFAULT_SCHEMAS[dbName as keyof typeof DEFAULT_SCHEMAS]) {
          console.log(`âŒ ì•Œ ìˆ˜ ì—†ëŠ” ë°ì´í„°ë² ì´ìŠ¤: ${dbName}`);
          continue;
        }

        const dbId = config.databases[dbName as keyof typeof config.databases];
        if (!dbId) {
          console.log(`âŒ ${dbName} ë°ì´í„°ë² ì´ìŠ¤ IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
          continue;
        }

        console.log(`ğŸ”„ ${dbName} ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ë¦¬ì…‹ ì¤‘...`);
        
        try {
          // ê¸°ì¡´ ë°ì´í„°ë² ì´ìŠ¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
          const database = await notionClient.getDatabase(dbId);
          
          // Name ì†ì„± ì œì™¸í•œ ëª¨ë“  ì†ì„± ì‚­ì œ ì¤€ë¹„
          const propertiesToDelete: any = {};
          const properties = 'properties' in database ? database.properties : {};
          Object.keys(properties).forEach(propName => {
            if (propName !== 'Name') {
              propertiesToDelete[propName] = null;
            }
          });
          
          // ê¸°ì¡´ ì†ì„±ë“¤ ì‚­ì œ
          if (Object.keys(propertiesToDelete).length > 0) {
            await notionClient.updateDatabaseSchema(dbId, propertiesToDelete);
            console.log(`   ğŸ—‘ï¸  ê¸°ì¡´ ì†ì„± ${Object.keys(propertiesToDelete).length}ê°œ ì‚­ì œ`);
          }
          
          // ìƒˆë¡œìš´ ìŠ¤í‚¤ë§ˆ ì ìš©
          const schema = DEFAULT_SCHEMAS[dbName as keyof typeof DEFAULT_SCHEMAS];
          await notionClient.updateDatabaseSchema(dbId, schema);
          console.log(`   âœ… ${dbName} ìƒˆ ìŠ¤í‚¤ë§ˆ ì ìš© ì™„ë£Œ`);
        } catch (error: any) {
          console.log(`   âŒ ${dbName} ë¦¬ì…‹ ì‹¤íŒ¨: ${error.message}`);
        }
      }
      
      console.log('\nğŸ‰ ìŠ¤í‚¤ë§ˆ ë¦¬ì…‹ ì™„ë£Œ!');
    } catch (error: any) {
      console.error(`ğŸ’¥ ë¦¬ì…‹ ì‹¤íŒ¨: ${error.message}`);
      process.exit(1);
    }
  });

// ìë™ ë³µêµ¬ ëª…ë ¹
program
  .command('repair')
  .description('ì•„ì¹´ì´ë¸Œëœ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ìë™ìœ¼ë¡œ ê°ì§€í•˜ê³  ë³µêµ¬í•©ë‹ˆë‹¤')
  .option('-d, --database <name>', 'íŠ¹ì • ë°ì´í„°ë² ì´ìŠ¤ë§Œ ë³µêµ¬')
  .option('--dry-run', 'ì‹¤ì œ ì‘ì—… ì—†ì´ ì‹œë®¬ë ˆì´ì…˜ë§Œ ì‹¤í–‰')
  .action(async (options) => {
    console.log('ğŸ”§ ë°ì´í„°ë² ì´ìŠ¤ ìë™ ë³µêµ¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...\n');
    
    try {
      const { config } = await getConfigService();
      const results = {
        repaired: [] as string[],
        created: [] as string[],
        errors: [] as string[]
      };
      
      // ëŒ€ìƒ ë°ì´í„°ë² ì´ìŠ¤ë“¤
      const allDatabases = ['files', 'functions', 'dependencies', 'libraries', 'classes'];
      const targetDatabases = options.database ? [options.database] : allDatabases;
      
      for (const dbName of targetDatabases) {
        console.log(`\nğŸ” ${dbName.toUpperCase()} ë°ì´í„°ë² ì´ìŠ¤ í™•ì¸ ì¤‘...`);
        
        const dbId = config.databases[dbName as keyof typeof config.databases];
        if (!dbId) {
          console.log(`âŒ ${dbName}: ì„¤ì •ì—ì„œ ë°ì´í„°ë² ì´ìŠ¤ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
          results.errors.push(`${dbName}: No database ID configured`);
          continue;
        }
        
        try {
          // ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ í™•ì¸
          const database = await notionClient.getDatabase(dbId);
          
          // ì‹¤ì œ ì—…ë°ì´íŠ¸ ì‹œë„ë¡œ ì•„ì¹´ì´ë¸Œ ìƒíƒœ í™•ì¸
          let isArchived = false;
          try {
            if (!options.dryRun) {
              await notionClient.updateDatabaseSchema(dbId, {
                "Test Property": { type: "rich_text", rich_text: {} }
              });
              
              // í…ŒìŠ¤íŠ¸ ì†ì„± ì œê±°
              await notionClient.updateDatabaseSchema(dbId, {
                "Test Property": null
              });
            }
            
            console.log(`   ìƒíƒœ: active`);
            
            // FILES ë°ì´í„°ë² ì´ìŠ¤ì˜ ê²½ìš° ê´€ê³„ ì†ì„± í™•ì¸
            if (dbName === 'files') {
              const dbProperties = 'properties' in database ? database.properties : {};
              if (!dbProperties?.['Imports']) {
                console.log(`ğŸ” ${dbName}: Imports ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤. ì¶”ê°€í•©ë‹ˆë‹¤.`);
                
                if (!options.dryRun) {
                  await notionClient.updateDatabaseSchema(dbId, {
                    "Imports": {
                      type: "relation",
                      relation: {
                        database_id: dbId, // ìê¸° ì°¸ì¡°
                        type: "single_property",
                        single_property: {}
                      }
                    }
                  });
                  console.log(`âœ… ${dbName}: Imports ê´€ê³„ ì†ì„± ì¶”ê°€ ì™„ë£Œ`);
                } else {
                  console.log(`ğŸ”„ [DRY RUN] ${dbName}: Imports ê´€ê³„ ì†ì„±ì„ ì¶”ê°€í•  ì˜ˆì •`);
                }
                
                results.repaired.push(dbName);
              } else {
                console.log(`âœ… ${dbName}: ì´ë¯¸ Imports ì†ì„±ì´ ì¡´ì¬í•©ë‹ˆë‹¤.`);
              }
            } else {
              console.log(`âœ… ${dbName}: ì •ìƒ ìƒíƒœì…ë‹ˆë‹¤.`);
            }
            
          } catch (updateError: any) {
            if (updateError.message?.includes('archived') || 
                updateError.message?.includes("Can't edit block that is archived")) {
              isArchived = true;
            } else {
              console.log(`âœ… ${dbName}: ì •ìƒ ìƒíƒœì…ë‹ˆë‹¤.`);
            }
          }
          
          if (isArchived) {
            console.log(`   ìƒíƒœ: archived`);
            console.log(`ğŸ“¦ ${dbName}: ì•„ì¹´ì´ë¸Œ ìƒíƒœ -> ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.`);
            
            if (!options.dryRun) {
              // ìƒˆ ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±
              const schema = DEFAULT_SCHEMAS[dbName as keyof typeof DEFAULT_SCHEMAS];
              if (schema) {
                // NotionClientì˜ createDatabase ë©”ì„œë“œ ì‚¬ìš©
                const { NotionClient } = await import('../../infrastructure/notion/NotionClient.js');
                const notionService = new NotionClient(
                  process.env.NOTION_API_KEY || config.apiKey || '',
                  process.cwd()
                );
                const response = await notionService.createDatabase(
                  `dependency-linker - ${dbName.charAt(0).toUpperCase() + dbName.slice(1)}`,
                  'files'
                );
                
                // ì„¤ì • íŒŒì¼ ì—…ë°ì´íŠ¸ - responseê°€ stringì´ë¯€ë¡œ ì§ì ‘ ì‚¬ìš©
                const responseId = typeof response === 'string' ? response : response;
                console.log(`âœ… ${dbName} ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ì™„ë£Œ: ${responseId}`);
                
                // FILES ë°ì´í„°ë² ì´ìŠ¤ì˜ ê²½ìš° ê´€ê³„ ì†ì„±ë„ ì¶”ê°€
                if (dbName === 'files') {
                  await notionClient.updateDatabaseSchema(responseId, {
                    "Imports": {
                      type: "relation",
                      relation: {
                        database_id: responseId,
                        type: "dual_property", 
                        dual_property: {
                          synced_property_name: "Imported By",
                          synced_property_id: "imported_by_relation"
                        }
                      }
                    }
                  });
                  console.log(`âœ… ${dbName}: Imports ê´€ê³„ ì†ì„± ì¶”ê°€ ì™„ë£Œ`);
                }
                
                results.created.push(dbName);
              } else {
                console.log(`âŒ ${dbName}: ìŠ¤í‚¤ë§ˆ ì •ì˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
                results.errors.push(`${dbName}: No schema definition found`);
              }
            } else {
              console.log(`ğŸ”„ [DRY RUN] ${dbName}: ìƒˆ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ìƒì„±í•  ì˜ˆì •`);
              results.created.push(dbName);
            }
          }
          
        } catch (error: any) {
          console.log(`âŒ ${dbName}: ì˜¤ë¥˜ ìƒíƒœ - ${error.message}`);
          results.errors.push(`${dbName}: ${error.message}`);
        }
      }
      
      // ê²°ê³¼ ì¶œë ¥
      console.log('\nğŸ‰ ìë™ ë³µêµ¬ ì™„ë£Œ!');
      console.log('==================');
      
      if (results.created.length > 0) {
        console.log(`ğŸ—ï¸ ìƒˆë¡œ ìƒì„±: ${results.created.join(', ')}`);
      }
      
      if (results.repaired.length > 0) {
        console.log(`ğŸ”§ ë³µêµ¬ ì™„ë£Œ: ${results.repaired.join(', ')}`);
      }
      
      if (results.errors.length > 0) {
        console.log(`âŒ ì˜¤ë¥˜ ë°œìƒ: ${results.errors.length}ê°œ`);
        results.errors.forEach(error => console.log(`   - ${error}`));
      }
      
      if (options.dryRun) {
        console.log('\nğŸ’¡ ì‹¤ì œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë ¤ë©´ --dry-run í”Œë˜ê·¸ë¥¼ ì œê±°í•˜ê³  ë‹¤ì‹œ ì‹¤í–‰í•˜ì„¸ìš”.');
      } else {
        console.log('\nğŸ” ìµœì¢… ê²€ì¦: bun run db:check ëª…ë ¹ìœ¼ë¡œ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.');
      }
      
    } catch (error: any) {
      console.error(`ğŸ’¥ ìë™ ë³µêµ¬ ì‹¤íŒ¨: ${error.message}`);
      process.exit(1);
    }
  });

// ì™„ì „í•œ Files DB ìƒì„± ëª…ë ¹
program
  .command('create-complete-files')
  .description('initial_data_source ë°©ì‹ìœ¼ë¡œ ì™„ì „í•œ Files ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤')
  .option('--replace', 'ê¸°ì¡´ Files ë°ì´í„°ë² ì´ìŠ¤ë¥¼ êµì²´í•©ë‹ˆë‹¤')
  .option('--dry-run', 'ì‹¤ì œ ì‘ì—… ì—†ì´ ì‹œë®¬ë ˆì´ì…˜ë§Œ ì‹¤í–‰')
  .action(async (options) => {
    console.log('ğŸ—ï¸ initial_data_source ë°©ì‹ìœ¼ë¡œ ì™„ì „í•œ Files ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤...\n');
    
    try {
      const { config } = await getConfigService();
      
      if (!config.parentPageId) {
        console.log('âŒ Parent Page IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        process.exit(1);
      }

      // í•„ìš”í•œ ë‹¤ë¥¸ ë°ì´í„°ë² ì´ìŠ¤ë“¤ í™•ì¸
      const requiredDBs = ['dependencies', 'libraries', 'functions'];
      for (const dbName of requiredDBs) {
        const dbId = config.databases[dbName as keyof typeof config.databases];
        if (!dbId) {
          console.log(`âŒ ${dbName} ë°ì´í„°ë² ì´ìŠ¤ IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
          console.log(`ğŸ’¡ ë¨¼ì € 'bun run db:init' ëª…ë ¹ìœ¼ë¡œ ë‹¤ë¥¸ ë°ì´í„°ë² ì´ìŠ¤ë“¤ì„ ìƒì„±í•˜ì„¸ìš”.`);
          process.exit(1);
        }
      }

      if (options.dryRun) {
        console.log('ğŸ” [DRY RUN] ì™„ì „í•œ Files ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ì‹œë®¬ë ˆì´ì…˜');
        console.log('   ğŸ“‹ í¬í•¨ë  ì†ì„±ë“¤:');
        console.log('      - Name (title)');
        console.log('      - File Path (rich_text)');
        console.log('      - Size (bytes) (number)');
        console.log('      - Extension (select)');
        console.log('      - Project (select)');
        console.log('      - Status (select)');
        console.log('      - Last Modified (date)');
        console.log('      - Dependencies (relation â†’ Dependencies DB)');
        console.log('      - Libraries (relation â†’ Libraries DB)');
        console.log('      - Functions (relation â†’ Functions DB)');
        console.log('\nğŸ’¡ ì‹¤ì œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë ¤ë©´ --dry-run í”Œë˜ê·¸ë¥¼ ì œê±°í•˜ê³  ë‹¤ì‹œ ì‹¤í–‰í•˜ì„¸ìš”.');
        return;
      }

      // ê¸°ì¡´ Files ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ì •ë³´ í‘œì‹œ
      if (options.replace && config.databases.files) {
        console.log(`ğŸ“¦ ê¸°ì¡´ Files ë°ì´í„°ë² ì´ìŠ¤: ${config.databases.files}`);
        console.log(`ğŸ”— ë°±ì—… ë§í¬: https://www.notion.so/graph-mcp/${config.databases.files.replace(/-/g, '')}`);
      }

      // ì™„ì „í•œ Files ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±
      const newFilesDbId = await notionClient.createCompleteFilesDatabase(config.parentPageId);
      
      console.log(`\nâœ… ì™„ì „í•œ Files ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ì„±ê³µ!`);
      console.log(`ğŸ†” ìƒˆ Database ID: ${newFilesDbId}`);
      console.log(`ğŸ”— ìƒˆ DB ë§í¬: https://www.notion.so/graph-mcp/${newFilesDbId.replace(/-/g, '')}`);

      // ì„¤ì • íŒŒì¼ ì—…ë°ì´íŠ¸
      if (options.replace) {
        const { configService } = await getConfigService();
        // Note: This would need to be implemented in ConfigurationService
        // For now, we'll note this as a TODO for configuration updates
        console.log('âš ï¸ Configuration update functionality needs to be implemented in ConfigurationService');
        console.log(`\nğŸ”„ ì„¤ì • íŒŒì¼ ì—…ë°ì´íŠ¸ ì™„ë£Œ - Files DB IDë¥¼ ìƒˆë¡œìš´ DBë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.`);
      } else {
        console.log(`\nğŸ’¡ --replace ì˜µì…˜ì„ ì‚¬ìš©í•˜ë©´ ì„¤ì • íŒŒì¼ì˜ Files DB IDë¥¼ ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
      }

      // ê²€ì¦ í˜ì´ì§€ ìƒì„±
      console.log(`\nğŸ§ª ê²€ì¦ í˜ì´ì§€ ìƒì„± ì¤‘...`);
      
      const testPage = await notionClient.createPage('files' as any, {
        "Name": { title: [{ text: { content: "Complete DB Verification" } }] },
        "File Path": { rich_text: [{ text: { content: "/test/verification.ts" } }] },
        "Extension": { select: { name: ".ts" } },
        "Project": { select: { name: "dependency-linker" } },
        "Status": { select: { name: "Uploaded" } }
      });

      console.log(`âœ… ê²€ì¦ í˜ì´ì§€ ìƒì„± ì„±ê³µ`);
      console.log(`\nğŸ‰ ì™„ì „í•œ Files ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ì™„ë£Œ!`);
      console.log(`ğŸ“Š í¬í•¨ëœ ê´€ê³„ ì†ì„±: Dependencies, Libraries, Functions`);
      console.log(`ğŸ” 'bun run db:check' ëª…ë ¹ìœ¼ë¡œ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.`);

    } catch (error: any) {
      console.error(`ğŸ’¥ ì™„ì „í•œ Files DB ìƒì„± ì‹¤íŒ¨: ${error.message}`);
      if (error.body) {
        console.error('ìƒì„¸ ì˜¤ë¥˜:', JSON.stringify(error.body, null, 2));
      }
      process.exit(1);
    }
  });

// ë°ì´í„°ë² ì´ìŠ¤ ê¶Œí•œ ë° ì ‘ê·¼ ê²€ì¦ ëª…ë ¹
program
  .command('validate')
  .description('ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼ ê¶Œí•œì„ ë¶„ì„í•˜ê³  ìë™ ë³µêµ¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤')
  .option('-d, --database <name>', 'íŠ¹ì • ë°ì´í„°ë² ì´ìŠ¤ë§Œ ê²€ì¦')
  .option('--fix', 'ìë™ ë³µêµ¬ ì‹¤í–‰ (ê¸°ë³¸: ì‹œë®¬ë ˆì´ì…˜ë§Œ)')
  .option('--report', 'ìƒì„¸ ê²€ì¦ ë³´ê³ ì„œ ì¶œë ¥')
  .action(async (options) => {
    console.log('ğŸ” ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼ ê¶Œí•œ ê²€ì¦ì„ ì‹œì‘í•©ë‹ˆë‹¤...\n');
    
    try {
      // ì„¤ì • ë¡œë“œ
      const { config } = await getConfigService();
      
      // ê²€ì¦ ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
      const validationService = new DatabaseAccessValidationService();
      
      if (options.database) {
        // íŠ¹ì • ë°ì´í„°ë² ì´ìŠ¤ ê²€ì¦
        console.log(`ğŸ” ${options.database} ë°ì´í„°ë² ì´ìŠ¤ ê²€ì¦ ì¤‘...`);
        
        const dbId = config.databases[options.database as keyof typeof config.databases];
        if (!dbId) {
          console.log(`âŒ ${options.database} ë°ì´í„°ë² ì´ìŠ¤ IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
          process.exit(1);
        }
        
        const result = await validationService.validate(dbId, options.database);
        
        // ê²°ê³¼ ì¶œë ¥
        if (result.valid) {
          console.log(`âœ… ${options.database}: ì ‘ê·¼ ê¶Œí•œ ì •ìƒ`);
        } else {
          console.log(`âš ï¸ ${options.database}: ê¶Œí•œ ë¬¸ì œ ë°œê²¬`);
          
          result.errors.forEach(error => {
            console.log(`   âŒ ${error.code}: ${error.message}`);
          });
          
          result.warnings.forEach(warning => {
            console.log(`   âš ï¸ ${warning.code}: ${warning.message}`);
          });
          
          if (result.suggestions.length > 0) {
            console.log('\nğŸ’¡ ê¶Œì¥ í•´ê²°ì±…:');
            result.suggestions.forEach((suggestion, index) => {
              console.log(`   ${index + 1}. ${suggestion.message}`);
              if (suggestion.autoFixable) {
                console.log(`      ğŸ¤– ìë™ ìˆ˜ì • ê°€ëŠ¥`);
              }
            });
          }
        }
        
      } else {
        // ì „ì²´ ë°ì´í„°ë² ì´ìŠ¤ ê²€ì¦
        const result = await validationService.validateAllDatabaseAccess();
        
        // ê¸°ë³¸ ê²°ê³¼ ì¶œë ¥
        if (result.valid) {
          console.log('âœ… ëª¨ë“  ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼ ê¶Œí•œì´ ì •ìƒì…ë‹ˆë‹¤.');
        } else {
          console.log('âš ï¸ ì¼ë¶€ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ê¶Œí•œ ë¬¸ì œê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.\n');
          
          // ì˜¤ë¥˜ ìš”ì•½
          if (result.errors.length > 0) {
            console.log(`âŒ ì˜¤ë¥˜ ${result.errors.length}ê°œ:`);
            result.errors.forEach(error => {
              console.log(`   â€¢ ${error.code}: ${error.message}`);
            });
          }
          
          // ê²½ê³  ìš”ì•½
          if (result.warnings.length > 0) {
            console.log(`\nâš ï¸ ê²½ê³  ${result.warnings.length}ê°œ:`);
            result.warnings.forEach(warning => {
              console.log(`   â€¢ ${warning.code}: ${warning.message}`);
            });
          }
          
          // ìë™ ìˆ˜ì • ê°€ëŠ¥í•œ í•­ëª© í‘œì‹œ
          const autoFixable = result.suggestions.filter(s => s.autoFixable);
          if (autoFixable.length > 0) {
            console.log(`\nğŸ¤– ìë™ ìˆ˜ì • ê°€ëŠ¥ í•­ëª©: ${autoFixable.length}ê°œ`);
            console.log('ğŸ’¡ --fix í”Œë˜ê·¸ë¡œ ìë™ ìˆ˜ì •ì„ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
          }
        }
        
        // ìƒì„¸ ë³´ê³ ì„œ ì¶œë ¥
        if (options.report) {
          console.log('\nğŸ“Š ìƒì„¸ ê²€ì¦ ë³´ê³ ì„œ:');
          console.log('=====================================');
          
          const issues = validationService.getAccessIssues();
          if (issues.length > 0) {
            issues.forEach(issue => {
              console.log(`\nğŸ” ${issue.databaseName} (${issue.databaseId})`);
              console.log(`   ë¬¸ì œ ìœ í˜•: ${issue.issueType}`);
              console.log(`   ì‹¬ê°ë„: ${issue.severity}`);
              console.log(`   ì˜¤ë¥˜: ${issue.errorMessage}`);
              console.log(`   ìë™ ìˆ˜ì • ê°€ëŠ¥: ${issue.autoFixable ? 'ì˜ˆ' : 'ì•„ë‹ˆì˜¤'}`);
              
              if (issue.suggestedActions.length > 0) {
                console.log('   ê¶Œì¥ í•´ê²°ì±…:');
                issue.suggestedActions.forEach((action, index) => {
                  console.log(`     ${index + 1}. ${action.description}`);
                  if (action.autoExecutable) {
                    console.log(`        ğŸ¤– ìë™ ì‹¤í–‰ ê°€ëŠ¥ (ìš°ì„ ìˆœìœ„: ${action.priority})`);
                  }
                });
              }
            });
          } else {
            console.log('ëª¨ë“  ë°ì´í„°ë² ì´ìŠ¤ê°€ ì •ìƒ ìƒíƒœì…ë‹ˆë‹¤.');
          }
        }
      }
      
      // ìë™ ë³µêµ¬ ì‹¤í–‰
      if (options.fix) {
        console.log('\nğŸ”§ ìë™ ë³µêµ¬ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤...');
        
        const remediationResult = await validationService.executeAutoRemediation(false);
        
        console.log('\nğŸ“Š ìë™ ë³µêµ¬ ê²°ê³¼:');
        console.log(`   ì‹œë„: ${remediationResult.attempted}ê°œ`);
        console.log(`   ì„±ê³µ: ${remediationResult.successful}ê°œ`);
        console.log(`   ì‹¤íŒ¨: ${remediationResult.failed}ê°œ`);
        
        if (remediationResult.details.length > 0) {
          console.log('\nìƒì„¸ ë‚´ì—­:');
          remediationResult.details.forEach(detail => {
            console.log(`   ${detail}`);
          });
        }
        
        if (remediationResult.successful > 0) {
          console.log('\nâœ… ì¼ë¶€ ë¬¸ì œê°€ ìë™ìœ¼ë¡œ í•´ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.');
          console.log('ğŸ” ë³€ê²½ì‚¬í•­ì„ í™•ì¸í•˜ë ¤ë©´ ë‹¤ì‹œ ê²€ì¦í•´ë³´ì„¸ìš”: bun run db:validate');
        }
      } else if (!options.database) {
        // ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
        const remediationResult = await validationService.executeAutoRemediation(true);
        
        if (remediationResult.attempted > 0) {
          console.log('\nğŸ” ìë™ ë³µêµ¬ ì‹œë®¬ë ˆì´ì…˜:');
          console.log(`   ìˆ˜ì • ê°€ëŠ¥í•œ í•­ëª©: ${remediationResult.attempted}ê°œ`);
          console.log('ğŸ’¡ ì‹¤ì œ ìˆ˜ì •ì„ í•˜ë ¤ë©´ --fix í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.');
        }
      }
      
      console.log('\nğŸ‰ ë°ì´í„°ë² ì´ìŠ¤ ê¶Œí•œ ê²€ì¦ ì™„ë£Œ!');
      
    } catch (error: any) {
      console.error(`ğŸ’¥ ê²€ì¦ ì‹¤íŒ¨: ${error.message}`);
      process.exit(1);
    }
  });

// JSON ìŠ¤í‚¤ë§ˆ ê¸°ë°˜ ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ëª…ë ¹
program
  .command('create-with-schema')
  .description('JSON ìŠ¤í‚¤ë§ˆ ê¸°ë°˜ìœ¼ë¡œ ì™„ì „í•œ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤')
  .requiredOption('-t, --type <type>', 'ë°ì´í„°ë² ì´ìŠ¤ íƒ€ì… (files, dependencies, libraries, functions, classes, relationships)')
  .option('--replace', 'ê¸°ì¡´ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ êµì²´í•©ë‹ˆë‹¤')
  .option('--dry-run', 'ì‹¤ì œ ì‘ì—… ì—†ì´ ì‹œë®¬ë ˆì´ì…˜ë§Œ ì‹¤í–‰')
  .action(async (options) => {
    console.log(`ğŸ—ï¸ JSON ìŠ¤í‚¤ë§ˆ ê¸°ë°˜ìœ¼ë¡œ ${options.type} ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤...\n`);
    
    try {
      // ì„¤ì • ë¡œë“œ
      const { config } = await getConfigService();
      
      if (!config.parentPageId) {
        console.log('âŒ Parent Page IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        process.exit(1);
      }

      // ìŠ¤í‚¤ë§ˆ í™•ì¸ (ì„ì‹œ ë¹„í™œì„±í™” - ìˆœí™˜ ì˜ì¡´ì„± í•´ê²° í•„ìš”)
      // const schema = schemaManager.getDatabaseSchema(options.type);
      // if (!schema) {
      //   console.log(`âŒ "${options.type}" íƒ€ì…ì— ëŒ€í•œ ìŠ¤í‚¤ë§ˆë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
      //   console.log('ğŸ“‹ ì‚¬ìš© ê°€ëŠ¥í•œ íƒ€ì…:', schemaManager.getAllDatabaseTypes().join(', '));
      //   process.exit(1);
      // }

      // ê´€ê³„ ëŒ€ìƒ ë°ì´í„°ë² ì´ìŠ¤ë“¤ í™•ì¸ (ì„ì‹œ ë¹„í™œì„±í™”)
      // const relationTargets = schemaManager.getRelationTargets(options.type);
      // for (const target of relationTargets) {
      //   const targetDbId = config.databases[target as keyof typeof config.databases];
      //   if (!targetDbId) {
      //     console.log(`âŒ ê´€ê³„ ëŒ€ìƒ "${target}" ë°ì´í„°ë² ì´ìŠ¤ IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
      //     console.log(`ğŸ’¡ ë¨¼ì € 'bun run db:init' ëª…ë ¹ìœ¼ë¡œ í•„ìš”í•œ ë°ì´í„°ë² ì´ìŠ¤ë“¤ì„ ìƒì„±í•˜ì„¸ìš”.`);
      //     process.exit(1);
      //   }
      // }

      if (options.dryRun) {
        console.log(`ğŸ” [DRY RUN] ${options.type} ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ì‹œë®¬ë ˆì´ì…˜`);
        console.log(`ğŸ“‹ ë°ì´í„°ë² ì´ìŠ¤ ì •ë³´:`);
        console.log(`   ì œëª©: ${options.type} Database`);
        console.log(`   ì„¤ëª…: JSON ìŠ¤í‚¤ë§ˆ ê¸°ë°˜ ë°ì´í„°ë² ì´ìŠ¤`);
        
        console.log(`\nğŸ“Š ê¸°ë³¸ ì†ì„±ë“¤:`);
        console.log(`   - Name (title)`);
        console.log(`   - Status (select)`);
        
        console.log('\nğŸ’¡ ì‹¤ì œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë ¤ë©´ --dry-run í”Œë˜ê·¸ë¥¼ ì œê±°í•˜ê³  ë‹¤ì‹œ ì‹¤í–‰í•˜ì„¸ìš”.');
        return;
      }

      // ê¸°ì¡´ ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ì •ë³´ í‘œì‹œ
      if (options.replace && config.databases[options.type as keyof typeof config.databases]) {
        const existingDbId = config.databases[options.type as keyof typeof config.databases];
        console.log(`ğŸ“¦ ê¸°ì¡´ ${options.type} ë°ì´í„°ë² ì´ìŠ¤: ${existingDbId}`);
        console.log(`ğŸ”— ë°±ì—… ë§í¬: https://www.notion.so/graph-mcp/${existingDbId.replace(/-/g, '')}`);
      }

      // ì™„ì „í•œ ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±
      const newDbId = await notionClient.createCompleteDatabaseWithSchema(options.type, config.parentPageId);
      
      console.log(`\nâœ… ì™„ì „í•œ ${options.type} ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ì„±ê³µ!`);
      console.log(`ğŸ†” ìƒˆ Database ID: ${newDbId}`);
      console.log(`ğŸ”— ìƒˆ DB ë§í¬: https://www.notion.so/graph-mcp/${newDbId.replace(/-/g, '')}`);

      // ì„¤ì • íŒŒì¼ ì—…ë°ì´íŠ¸
      if (options.replace) {
        const { configService } = await getConfigService();
        // Note: This would need to be implemented in ConfigurationService
        // For now, we'll note this as a TODO for configuration updates
        console.log('âš ï¸ Configuration update functionality needs to be implemented in ConfigurationService');
        console.log(`\nğŸ”„ ì„¤ì • íŒŒì¼ ì—…ë°ì´íŠ¸ ì™„ë£Œ - ${options.type} DB IDë¥¼ ìƒˆë¡œìš´ DBë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.`);
      } else {
        console.log(`\nğŸ’¡ --replace ì˜µì…˜ì„ ì‚¬ìš©í•˜ë©´ ì„¤ì • íŒŒì¼ì˜ ${options.type} DB IDë¥¼ ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
      }

      console.log(`\nğŸ‰ ì™„ì „í•œ ${options.type} ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ì™„ë£Œ!`);
      console.log(`ğŸ“Š JSON ìŠ¤í‚¤ë§ˆ ê¸°ë°˜ ìƒì„±ìœ¼ë¡œ ëª¨ë“  ì†ì„±ê³¼ ê´€ê³„ê°€ í¬í•¨ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      console.log(`ğŸ” 'bun run db:check' ëª…ë ¹ìœ¼ë¡œ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.`);

    } catch (error: any) {
      console.error(`ğŸ’¥ ${options.type} DB ìƒì„± ì‹¤íŒ¨: ${error.message}`);
      if (error.body) {
        console.error('ìƒì„¸ ì˜¤ë¥˜:', JSON.stringify(error.body, null, 2));
      }
      process.exit(1);
    }
  });

export { program };

// CLI ìŠ¤í¬ë¦½íŠ¸ë¡œ ì§ì ‘ ì‹¤í–‰ë  ë•Œ
if (import.meta.main) {
  program.parse();
}