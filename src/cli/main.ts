/**
 * Clean CLI Entry Point
 * Ìï∏Îì§Îü¨ Í∏∞Î∞ò ÏïÑÌÇ§ÌÖçÏ≤òÎ°ú Íµ¨ÏÑ±Îêú ÍπîÎÅîÌïú CLI
 */

import { Command } from "commander";
import { glob } from "glob";

// Ìï∏Îì§Îü¨ ÏûÑÌè¨Ìä∏
import {
	runMarkdownAnalysis,
	runLinkTracking,
	runHeadingExtraction,
	runTagCollection,
	runTagHeadingMapping,
	runTagDocumentGeneration,
	runTagTypeValidation,
	runTagTypeDocumentGeneration,
} from "./handlers/markdown-handler.js";
import {
	runTypeScriptAnalysis,
	runTypeScriptProjectAnalysis,
	runTypeScriptPerformanceBenchmark,
} from "./handlers/typescript-handler.js";
import { RDFHandler, UnknownSymbolHandler, QueryHandler, CrossNamespaceHandler, InferenceHandler, ContextDocumentsHandler, PerformanceOptimizationHandler, HandlerFactory } from "./handlers/index.js";
import { RDFFileHandler } from "./handlers/rdf-file-handler.js";

// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∞è RDF Í¥ÄÎ†® ÏûÑÌè¨Ìä∏
import {
	runNamespaceAnalysis,
} from "../namespace/analysis-namespace.js";
import {
	createRDFAddress,
	validateRDFAddress,
} from "../core/RDFAddress.js";
import { RDFDatabaseAPI } from "../api/rdf-database-integration.js";

// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÏµúÏ†ÅÌôî
import { NamespaceOptimizer } from "../cli/namespace-optimizer.js";

const program = new Command();

program
	.name("dependency-linker")
	.description("Advanced dependency analysis tool")
	.version("2.1.0");

// ============================================================================
// Í∏∞Î≥∏ Î∂ÑÏÑù Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("analyze")
	.description("Analyze files for dependencies")
	.option("-p, --pattern <pattern>", "File pattern to analyze", "src/**/*.ts")
	.option("-d, --directory <dir>", "Directory to analyze", ".")
	.option("-t, --type <type>", "Analysis type", "fixed")
	.option("--performance", "Enable performance optimizations")
	.option("--max-concurrency <num>", "Max concurrent files", "4")
	.option("--batch-size <num>", "Batch size for processing", "10")
	.option("--memory-limit <mb>", "Memory limit in MB", "1024")
	.option("-o, --output <file>", "Output file")
	.option("--format <format>", "Output format", "json")
	.option("--include-statistics", "Include detailed statistics")
	.action(async (options) => {
		try {
			console.log("üîç Running analysis...\n");

			// ÌååÏùº Ìå®ÌÑ¥ÏúºÎ°ú ÌååÏùº Ï∞æÍ∏∞
			const files = await glob(options.pattern, { cwd: options.directory });

			if (files.length === 0) {
				console.log("‚ùå No files found matching the pattern");
				return;
			}

			console.log(`üìÅ Found ${files.length} files to analyze`);

			// TypeScript ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù Ïã§Ìñâ
			await runTypeScriptProjectAnalysis(options.pattern, {
				performance: options.performance,
				maxConcurrency: options.maxConcurrency,
				batchSize: options.batchSize,
				memoryLimit: options.memoryLimit,
				output: options.output,
				format: options.format,
				includeStatistics: options.includeStatistics,
			});

			console.log(`\n‚úÖ Analysis completed`);
		} catch (error) {
			console.error("‚ùå Analysis failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// ÎßàÌÅ¨Îã§Ïö¥ Î∂ÑÏÑù Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("markdown")
	.description("Markdown analysis commands")
	.option("-n, --name <namespace>", "Namespace name")
	.option("-a, --action <action>", "Action to perform", "analysis")
	.action(async (options) => {
		if (!options.name) {
			console.log("‚ùå Please specify --name <namespace>");
			process.exit(1);
		}

		try {
			switch (options.action) {
				case "analysis":
					await runMarkdownAnalysis(options.name);
					break;
				case "links":
					await runLinkTracking(options.name);
					break;
				case "headings":
					await runHeadingExtraction(options.name);
					break;
				case "tags":
					await runTagCollection(options.name);
					break;
				case "mapping":
					await runTagHeadingMapping(options.name);
					break;
				case "document":
					await runTagDocumentGeneration(options.name);
					break;
				case "validation":
					await runTagTypeValidation(options.name);
					break;
				case "type-doc":
					await runTagTypeDocumentGeneration(options.name);
					break;
				default:
					console.log(
						"‚ùå Unknown action. Available: analysis, links, headings, tags, mapping, document, validation, type-doc",
					);
					process.exit(1);
			}
		} catch (error) {
			console.error(`‚ùå Markdown ${options.action} failed:`, error);
			process.exit(1);
		}
	});

// ============================================================================
// TypeScript Î∂ÑÏÑù Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("typescript")
	.description("TypeScript analysis commands")
	.option("-f, --file <file>", "File to analyze")
	.option("-p, --pattern <pattern>", "File pattern to analyze")
	.option("-t, --type <type>", "Analysis type", "fixed")
	.option("--performance", "Enable performance optimizations")
	.option("-o, --output <file>", "Output file")
	.option("--format <format>", "Output format", "json")
	.option("--include-statistics", "Include detailed statistics")
	.action(async (options) => {
		try {
			if (options.file) {
				// Îã®Ïùº ÌååÏùº Î∂ÑÏÑù
				await runTypeScriptAnalysis(options.file, {
					analysisType: options.type,
					performance: options.performance,
					output: options.output,
					format: options.format,
					includeStatistics: options.includeStatistics,
				});
			} else if (options.pattern) {
				// Ìå®ÌÑ¥ Í∏∞Î∞ò Î∂ÑÏÑù
				await runTypeScriptProjectAnalysis(options.pattern, {
					performance: options.performance,
					output: options.output,
					format: options.format,
					includeStatistics: options.includeStatistics,
				});
			} else {
				console.log("‚ùå Please specify either --file or --pattern");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå TypeScript analysis failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨ Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("benchmark")
	.description("Performance benchmark")
	.option("-n, --name <name>", "Benchmark name", "default")
	.option("-t, --type <type>", "Benchmark type", "typescript")
	.action(async (options) => {
		try {
			if (options.type === "typescript") {
				await runTypeScriptPerformanceBenchmark(options.name);
			} else {
				console.log("‚ùå Unknown benchmark type. Available: typescript");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Benchmark failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Í¥ÄÎ¶¨ Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("namespace")
	.description("Namespace management")
	.option("-l, --list", "List namespaces")
	.option("-n, --name <name>", "Namespace name")
	.option("-a, --all", "Run all namespaces")
	.option("-o, --optimize", "Optimize namespace")
	.action(async (options) => {
		try {
			if (options.list) {
				console.log("üìã Available namespaces:");
				console.log("   - source: Source code analysis");
				console.log("   - markdown: Markdown analysis");
				console.log("   - typescript: TypeScript analysis");
			} else if (options.name) {
				await runNamespaceAnalysis(options.name);
			} else if (options.all) {
				const namespaces = ["source", "markdown", "typescript"];
				for (const ns of namespaces) {
					console.log(`\nüîÑ Running namespace: ${ns}`);
					await runNamespaceAnalysis(ns);
				}
			} else if (options.optimize) {
				console.log("üîß Namespace optimization is not yet implemented");
			} else {
				console.log(
					"‚ùå Please specify an action: --list, --name, --all, or --optimize",
				);
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Namespace operation failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// RDF Í¥ÄÎ†® Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("rdf")
	.description("RDF operations")
	.option("-c, --create", "Create RDF address")
	.option("-p, --project <project>", "Project name")
	.option("-f, --file <file>", "File path")
	.option("-t, --type <type>", "Node type")
	.option("-s, --symbol <symbol>", "Symbol name")
	.option("-q, --query <query>", "Search query")
	.option("-n, --namespace <namespace>", "Namespace name")
	.option("-v, --validate", "Validate RDF address")
	.option("-a, --address <address>", "RDF address to validate")
	.option("--uniqueness", "Check uniqueness")
	.option("--stats", "Show RDF statistics")
	.option("--by-type", "Group statistics by type")
	.option("--all", "Show all statistics")
	.action(async (options) => {
		const handler = new RDFHandler();
		try {
			// RDF Ï£ºÏÜå ÏÉùÏÑ±
			if (options.create) {
				if (!options.project || !options.file || !options.type || !options.symbol) {
					console.log("‚ùå Please specify --project, --file, --type, and --symbol");
					process.exit(1);
				}
				await handler.createRDFAddress({
					project: options.project,
					file: options.file,
					type: options.type,
					symbol: options.symbol
				});
			}
			// RDF Ï£ºÏÜå Í≤ÄÏÉâ
			else if (options.query) {
				await handler.searchRDFAddresses({
					query: options.query,
					namespace: options.namespace,
					project: options.project,
					file: options.file,
					type: options.type
				});
			}
			// RDF Ï£ºÏÜå Í≤ÄÏ¶ù
			else if (options.validate) {
				await handler.validateRDFAddress({
					address: options.address,
					namespace: options.namespace,
					uniqueness: options.uniqueness
				});
			}
			// RDF ÌÜµÍ≥Ñ
			else if (options.stats) {
				await handler.generateRDFStatistics({
					namespace: options.namespace,
					project: options.project,
					all: options.all,
					byType: options.byType
				});
			}
			else {
				console.log("‚ùå Please specify an RDF operation (--create, --query, --validate, --stats)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå RDF operation failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// Query System Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("query")
	.description("Query System Í¥ÄÎ¶¨")
	.option("-s, --sql <query>", "SQL ÏøºÎ¶¨ Ïã§Ìñâ")
	.option("-g, --graphql <query>", "GraphQL ÏøºÎ¶¨ Ïã§Ìñâ")
	.option("-n, --natural <query>", "ÏûêÏó∞Ïñ¥ ÏøºÎ¶¨ Ïã§Ìñâ")
	.option("-a, --auto <query>", "ÏûêÎèô ÏøºÎ¶¨ ÌÉÄÏûÖ Í∞êÏßÄ Î∞è Ïã§Ìñâ")
	.option("-r, --realtime", "Ïã§ÏãúÍ∞Ñ ÏøºÎ¶¨ Îì±Î°ù")
	.option("--query-type <type>", "ÏøºÎ¶¨ ÌÉÄÏûÖ (SQL, GraphQL, NaturalLanguage)")
	.option("--client-id <id>", "ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID")
	.option("--subscribe", "Ïã§ÏãúÍ∞Ñ ÏøºÎ¶¨ Íµ¨ÎèÖ")
	.option("--query-id <id>", "ÏøºÎ¶¨ ID")
	.option("--event-type <type>", "Ïù¥Î≤§Ìä∏ ÌÉÄÏûÖ (data, error, complete)")
	.option("--stats", "ÏøºÎ¶¨ ÏÑ±Îä• ÌÜµÍ≥Ñ")
	.option("--cache <action>", "Ï∫êÏãú Í¥ÄÎ¶¨ (clear, stats, optimize)")
	.option("--data-source <source>", "Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§")
	.action(async (options) => {
		const handler = new QueryHandler();
		try {
			await handler.initialize();

			// SQL ÏøºÎ¶¨ Ïã§Ìñâ
			if (options.sql) {
				await handler.executeSQLQuery(options.sql, options.dataSource || {});
			}
			// GraphQL ÏøºÎ¶¨ Ïã§Ìñâ
			else if (options.graphql) {
				await handler.executeGraphQLQuery(options.graphql, options.dataSource || {});
			}
			// ÏûêÏó∞Ïñ¥ ÏøºÎ¶¨ Ïã§Ìñâ
			else if (options.natural) {
				await handler.executeNaturalLanguageQuery(options.natural, options.dataSource || {});
			}
			// ÏûêÎèô ÏøºÎ¶¨ Ïã§Ìñâ
			else if (options.auto) {
				await handler.executeQuery(options.auto, options.dataSource || {});
			}
			// Ïã§ÏãúÍ∞Ñ ÏøºÎ¶¨ Îì±Î°ù
			else if (options.realtime) {
				if (!options.queryType || !options.clientId) {
					console.log("‚ùå Please specify --query-type and --client-id");
					process.exit(1);
				}
				await handler.registerRealtimeQuery(
					options.auto || options.sql || options.graphql || options.natural,
					options.queryType,
					options.clientId,
					options.dataSource || {}
				);
			}
			// Ïã§ÏãúÍ∞Ñ ÏøºÎ¶¨ Íµ¨ÎèÖ
			else if (options.subscribe) {
				if (!options.queryId || !options.clientId || !options.eventType) {
					console.log("‚ùå Please specify --query-id, --client-id, and --event-type");
					process.exit(1);
				}
				await handler.subscribeToRealtimeQuery(
					options.queryId,
					options.clientId,
					options.eventType
				);
			}
			// ÏøºÎ¶¨ ÌÜµÍ≥Ñ
			else if (options.stats) {
				await handler.getQueryStatistics();
			}
			// Ï∫êÏãú Í¥ÄÎ¶¨
			else if (options.cache) {
				await handler.manageCache(options.cache);
			}
			else {
				console.log("‚ùå Please specify a query operation (--sql, --graphql, --natural, --auto, --realtime, --subscribe, --stats, --cache)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Query operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Cross-Namespace Dependencies Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("cross-namespace")
	.description("Cross-Namespace Dependencies Í¥ÄÎ¶¨")
	.option("-n, --namespace <name>", "Îã®Ïùº ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù")
	.option("-m, --multiple <names>", "Îã§Ï§ë ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)")
	.option("-a, --all", "Ï†ÑÏ≤¥ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù")
	.option("-c, --cross", "Cross-Namespace ÏùòÏ°¥ÏÑ± Ï°∞Ìöå")
	.option("-s, --source <namespace>", "ÏÜåÏä§ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÌïÑÌÑ∞")
	.option("-t, --target <namespace>", "ÌÉÄÍ≤ü ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÌïÑÌÑ∞")
	.option("--circular", "ÏàúÌôò ÏùòÏ°¥ÏÑ± Ï°∞Ìöå")
	.option("--circular-namespace <name>", "ÌäπÏ†ï ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÏàúÌôò ÏùòÏ°¥ÏÑ± Ï°∞Ìöå")
	.option("--stats", "ÌÜµÍ≥Ñ ÏÉùÏÑ±")
	.option("--include-cross", "Cross-Namespace ÏùòÏ°¥ÏÑ± Ìè¨Ìï®")
	.option("--include-circular", "ÏàúÌôò ÏùòÏ°¥ÏÑ± Ìè¨Ìï®")
	.option("--include-graph", "Í∑∏ÎûòÌîÑ ÌÜµÍ≥Ñ Ìè¨Ìï®")
	.option("--config <path>", "ÏÑ§Ï†ï ÌååÏùº Í≤ΩÎ°ú")
	.option("--project-root <path>", "ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ Í≤ΩÎ°ú")
	.option("--cwd <path>", "ÏûëÏóÖ ÎîîÎ†âÌÜ†Î¶¨")
	.option("--max-concurrency <number>", "ÏµúÎåÄ ÎèôÏãú Ïã§Ìñâ Ïàò")
	.option("--enable-caching", "Ï∫êÏã± ÌôúÏÑ±Ìôî")
	.action(async (options) => {
		const handler = new CrossNamespaceHandler({
			configPath: options.config,
			projectRoot: options.projectRoot,
			cwd: options.cwd,
			maxConcurrency: options.maxConcurrency ? parseInt(options.maxConcurrency) : undefined,
			enableCaching: options.enableCaching,
		});

		try {
			await handler.initialize();

			// Îã®Ïùº ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù
			if (options.namespace) {
				await handler.analyzeNamespace(options.namespace, {
					includeCrossDependencies: options.includeCross,
					includeCircularDependencies: options.includeCircular,
				});
			}
			// Îã§Ï§ë ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù
			else if (options.multiple) {
				const namespaces = options.multiple.split(",").map((n: string) => n.trim());
				await handler.analyzeNamespaces(namespaces, {
					includeCrossDependencies: options.includeCross,
					includeStatistics: options.stats,
				});
			}
			// Ï†ÑÏ≤¥ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù
			else if (options.all) {
				await handler.analyzeAll({
					includeGraph: options.includeGraph,
					includeCrossDependencies: options.includeCross,
					includeStatistics: options.stats,
				});
			}
			// Cross-Namespace ÏùòÏ°¥ÏÑ± Ï°∞Ìöå
			else if (options.cross) {
				await handler.getCrossNamespaceDependencies({
					sourceNamespace: options.source,
					targetNamespace: options.target,
					includeStatistics: options.stats,
				});
			}
			// ÏàúÌôò ÏùòÏ°¥ÏÑ± Ï°∞Ìöå
			else if (options.circular) {
				await handler.getCircularDependencies(options.circularNamespace, {
					includeStatistics: options.stats,
				});
			}
			// ÌÜµÍ≥Ñ ÏÉùÏÑ±
			else if (options.stats) {
				await handler.generateStatistics({
					includeCrossDependencies: options.includeCross,
					includeCircularDependencies: options.includeCircular,
					includeGraphStatistics: options.includeGraph,
				});
			}
			else {
				console.log("‚ùå Please specify an operation (--namespace, --multiple, --all, --cross, --circular, --stats)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Cross-Namespace operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Inference System Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("inference")
	.description("Inference System Í¥ÄÎ¶¨")
	.option("-e, --execute <nodeId>", "ÌÜµÌï© Ï∂îÎ°† Ïã§Ìñâ")
	.option("-h, --hierarchical <nodeId>", "Í≥ÑÏ∏µÏ†Å Ï∂îÎ°† Ïã§Ìñâ")
	.option("-t, --transitive <nodeId>", "Ï†ÑÏù¥Ï†Å Ï∂îÎ°† Ïã§Ìñâ")
	.option("-i, --inheritable <nodeId>", "ÏÉÅÏÜç Í∞ÄÎä•Ìïú Ï∂îÎ°† Ïã§Ìñâ")
	.option("-o, --optimized <nodeId>", "ÏµúÏ†ÅÌôîÎêú Ï∂îÎ°† Ïã§Ìñâ")
	.option("-r, --realtime <nodeId>", "Ïã§ÏãúÍ∞Ñ Ï∂îÎ°† Ïã§Ìñâ")
	.option("-a, --all <nodeId>", "Î™®Îì† Ï∂îÎ°† Ïã§Ìñâ")
	.option("--edge-type <type>", "Ïó£ÏßÄ ÌÉÄÏûÖ")
	.option("--rule-ids <ids>", "Í∑úÏπô ID Î™©Î°ù (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)")
	.option("--include-children", "ÏûêÏãù ÎÖ∏Îìú Ìè¨Ìï®")
	.option("--max-depth <depth>", "ÏµúÎåÄ ÍπäÏù¥")
	.option("--max-path-length <length>", "ÏµúÎåÄ Í≤ΩÎ°ú Í∏∏Ïù¥")
	.option("--include-intermediate", "Ï§ëÍ∞Ñ ÎÖ∏Îìú Ìè¨Ìï®")
	.option("--include-inherited", "ÏÉÅÏÜçÎêú Í¥ÄÍ≥Ñ Ìè¨Ìï®")
	.option("--max-inheritance-depth <depth>", "ÏµúÎåÄ ÏÉÅÏÜç ÍπäÏù¥")
	.option("--enable-caching", "Ï∫êÏã± ÌôúÏÑ±Ìôî")
	.option("--enable-parallel", "Î≥ëÎ†¨ Ï≤òÎ¶¨ ÌôúÏÑ±Ìôî")
	.option("--max-concurrency <number>", "ÏµúÎåÄ ÎèôÏãú Ïã§Ìñâ Ïàò")
	.option("--enable-auto-inference", "ÏûêÎèô Ï∂îÎ°† ÌôúÏÑ±Ìôî")
	.option("--use-custom-rules", "ÏÇ¨Ïö©Ïûê Ï†ïÏùò Í∑úÏπô ÏÇ¨Ïö©")
	.option("--use-realtime", "Ïã§ÏãúÍ∞Ñ Ï∂îÎ°† ÏÇ¨Ïö©")
	.option("--use-optimized", "ÏµúÏ†ÅÌôîÎêú Ï∂îÎ°† ÏÇ¨Ïö©")
	.option("--use-legacy", "Î†àÍ±∞Ïãú Ï∂îÎ°† ÏÇ¨Ïö©")
	.option("--stats", "Ï∂îÎ°† ÌÜµÍ≥Ñ ÏÉùÏÑ±")
	.option("--cache <action>", "Ï∫êÏãú Í¥ÄÎ¶¨ (clear, stats, optimize)")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.option("--enable-custom-rules", "ÏÇ¨Ïö©Ïûê Ï†ïÏùò Í∑úÏπô ÌôúÏÑ±Ìôî")
	.option("--enable-realtime-inference", "Ïã§ÏãúÍ∞Ñ Ï∂îÎ°† ÌôúÏÑ±Ìôî")
	.option("--enable-optimized-inference", "ÏµúÏ†ÅÌôîÎêú Ï∂îÎ°† ÌôúÏÑ±Ìôî")
	.option("--enable-legacy-inference", "Î†àÍ±∞Ïãú Ï∂îÎ°† ÌôúÏÑ±Ìôî")
	.action(async (options) => {
		const handler = new InferenceHandler({
			databasePath: options.database,
			enableCustomRules: options.enableCustomRules,
			enableRealTimeInference: options.enableRealtimeInference,
			enableOptimizedInference: options.enableOptimizedInference,
			enableLegacyInference: options.enableLegacyInference,
			maxConcurrency: options.maxConcurrency ? parseInt(options.maxConcurrency) : undefined,
			enableCaching: options.enableCaching,
		});

		try {
			await handler.initialize();

			// ÌÜµÌï© Ï∂îÎ°† Ïã§Ìñâ
			if (options.execute) {
				const nodeId = parseInt(options.execute);
				await handler.executeInference(nodeId, {
					ruleIds: options.ruleIds ? options.ruleIds.split(",") : undefined,
					useCustomRules: options.useCustomRules,
					useRealTime: options.useRealtime,
					useOptimized: options.useOptimized,
					useLegacy: options.useLegacy,
				});
			}
			// Í≥ÑÏ∏µÏ†Å Ï∂îÎ°† Ïã§Ìñâ
			else if (options.hierarchical) {
				const nodeId = parseInt(options.hierarchical);
				if (!options.edgeType) {
					console.log("‚ùå Please specify --edge-type for hierarchical inference");
					process.exit(1);
				}
				await handler.executeHierarchicalInference(nodeId, options.edgeType, {
					includeChildren: options.includeChildren,
					maxDepth: options.maxDepth ? parseInt(options.maxDepth) : undefined,
				});
			}
			// Ï†ÑÏù¥Ï†Å Ï∂îÎ°† Ïã§Ìñâ
			else if (options.transitive) {
				const nodeId = parseInt(options.transitive);
				if (!options.edgeType) {
					console.log("‚ùå Please specify --edge-type for transitive inference");
					process.exit(1);
				}
				await handler.executeTransitiveInference(nodeId, options.edgeType, {
					maxPathLength: options.maxPathLength ? parseInt(options.maxPathLength) : undefined,
					includeIntermediate: options.includeIntermediate,
				});
			}
			// ÏÉÅÏÜç Í∞ÄÎä•Ìïú Ï∂îÎ°† Ïã§Ìñâ
			else if (options.inheritable) {
				const nodeId = parseInt(options.inheritable);
				if (!options.edgeType) {
					console.log("‚ùå Please specify --edge-type for inheritable inference");
					process.exit(1);
				}
				await handler.executeInheritableInference(nodeId, options.edgeType, {
					includeInherited: options.includeInherited,
					maxInheritanceDepth: options.maxInheritanceDepth ? parseInt(options.maxInheritanceDepth) : undefined,
				});
			}
			// ÏµúÏ†ÅÌôîÎêú Ï∂îÎ°† Ïã§Ìñâ
			else if (options.optimized) {
				const nodeId = parseInt(options.optimized);
				await handler.executeOptimizedInference(nodeId, {
					enableCaching: options.enableCaching,
					enableParallel: options.enableParallel,
					maxConcurrency: options.maxConcurrency ? parseInt(options.maxConcurrency) : undefined,
				});
			}
			// Ïã§ÏãúÍ∞Ñ Ï∂îÎ°† Ïã§Ìñâ
			else if (options.realtime) {
				const nodeId = parseInt(options.realtime);
				await handler.executeRealTimeInference(nodeId, {
					ruleIds: options.ruleIds ? options.ruleIds.split(",") : undefined,
					enableAutoInference: options.enableAutoInference,
				});
			}
			// Î™®Îì† Ï∂îÎ°† Ïã§Ìñâ
			else if (options.all) {
				const nodeId = parseInt(options.all);
				await handler.executeAllInferences(nodeId, {
					includeCustomRules: options.useCustomRules,
					includeRealTime: options.useRealtime,
					includeOptimized: options.useOptimized,
					includeLegacy: options.useLegacy,
				});
			}
			// Ï∂îÎ°† ÌÜµÍ≥Ñ
			else if (options.stats) {
				await handler.generateStatistics();
			}
			// Ï∫êÏãú Í¥ÄÎ¶¨
			else if (options.cache) {
				await handler.manageCache(options.cache);
			}
			else {
				console.log("‚ùå Please specify an inference operation (--execute, --hierarchical, --transitive, --inheritable, --optimized, --realtime, --all, --stats, --cache)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Inference operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Context Documents Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("context-documents")
	.description("Context Documents Í¥ÄÎ¶¨")
	.option("-f, --file <path>", "ÌååÏùº Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏÉùÏÑ±")
	.option("-s, --symbol <path>", "Ïã¨Î≥º Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏÉùÏÑ±")
	.option("-p, --project", "ÌîÑÎ°úÏ†ùÌä∏ Ï†ÑÏ≤¥ Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏÉùÏÑ±")
	.option("-l, --list", "Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú Î™©Î°ù Ï°∞Ìöå")
	.option("-u, --update", "Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏")
	.option("-c, --cleanup", "Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú Ï†ïÎ¶¨")
	.option("--stats", "Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÌÜµÍ≥Ñ ÏÉùÏÑ±")
	.option("--symbol-path <path>", "Ïã¨Î≥º Í≤ΩÎ°ú")
	.option("--symbol-kind <kind>", "Ïã¨Î≥º Ï¢ÖÎ•ò")
	.option("--include-files", "ÌååÏùº Î¨∏ÏÑú Ìè¨Ìï®")
	.option("--include-symbols", "Ïã¨Î≥º Î¨∏ÏÑú Ìè¨Ìï®")
	.option("--include-dependencies", "ÏùòÏ°¥ÏÑ± Ï†ïÎ≥¥ Ìè¨Ìï®")
	.option("--include-dependents", "ÏùòÏ°¥Ïûê Ï†ïÎ≥¥ Ìè¨Ìï®")
	.option("--include-metadata", "Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ìè¨Ìï®")
	.option("--overwrite-existing", "Í∏∞Ï°¥ Î¨∏ÏÑú ÎçÆÏñ¥Ïì∞Í∏∞")
	.option("--confirm", "ÏûëÏóÖ ÌôïÏù∏")
	.option("--project-root <path>", "ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ Í≤ΩÎ°ú")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.option("--output <path>", "Ï∂úÎ†• Í≤ΩÎ°ú")
	.option("--enable-auto-generation", "ÏûêÎèô ÏÉùÏÑ± ÌôúÏÑ±Ìôî")
	.action(async (options) => {
		const handler = new ContextDocumentsHandler({
			projectRoot: options.projectRoot,
			databasePath: options.database,
			outputPath: options.output,
			enableAutoGeneration: options.enableAutoGeneration,
			includeDependencies: options.includeDependencies,
			includeDependents: options.includeDependents,
			includeMetadata: options.includeMetadata,
			overwriteExisting: options.overwriteExisting,
		});

		try {
			await handler.initialize();

			// ÌååÏùº Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏÉùÏÑ±
			if (options.file) {
				await handler.generateFileContext(options.file, {
					includeDependencies: options.includeDependencies,
					includeDependents: options.includeDependents,
					overwriteExisting: options.overwriteExisting,
				});
			}
			// Ïã¨Î≥º Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏÉùÏÑ±
			else if (options.symbol) {
				if (!options.symbolPath) {
					console.log("‚ùå Please specify --symbol-path for symbol context generation");
					process.exit(1);
				}
				await handler.generateSymbolContext(options.symbol, options.symbolPath, {
					symbolKind: options.symbolKind,
					overwriteExisting: options.overwriteExisting,
				});
			}
			// ÌîÑÎ°úÏ†ùÌä∏ Ï†ÑÏ≤¥ Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏÉùÏÑ±
			else if (options.project) {
				await handler.generateProjectContext({
					includeFiles: options.includeFiles,
					includeSymbols: options.includeSymbols,
					includeDependencies: options.includeDependencies,
					includeDependents: options.includeDependents,
					overwriteExisting: options.overwriteExisting,
				});
			}
			// Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú Î™©Î°ù Ï°∞Ìöå
			else if (options.list) {
				await handler.listDocuments();
			}
			// Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏
			else if (options.update) {
				await handler.updateDocuments({
					includeFiles: options.includeFiles,
					includeSymbols: options.includeSymbols,
					includeDependencies: options.includeDependencies,
					includeDependents: options.includeDependents,
					overwriteExisting: options.overwriteExisting,
				});
			}
			// Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú Ï†ïÎ¶¨
			else if (options.cleanup) {
				await handler.cleanupDocuments({
					includeFiles: options.includeFiles,
					includeSymbols: options.includeSymbols,
					confirm: options.confirm,
				});
			}
			// Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÌÜµÍ≥Ñ
			else if (options.stats) {
				await handler.generateStatistics();
			}
			else {
				console.log("‚ùå Please specify an operation (--file, --symbol, --project, --list, --update, --cleanup, --stats)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Context Documents operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Performance Optimization Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("performance")
	.description("Performance Optimization Í¥ÄÎ¶¨")
	.option("-a, --analyze <project>", "ÏµúÏ†ÅÌôîÎêú ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù")
	.option("-c, --cache <action>", "Ï∫êÏãú Í¥ÄÎ¶¨ (clear, stats, optimize)")
	.option("-b, --batch <action>", "Î∞∞Ïπò Ï≤òÎ¶¨ Í¥ÄÎ¶¨ (start, stop, stats, retry)")
	.option("-m, --monitor", "ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë")
	.option("-o, --optimize-memory", "Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî")
	.option("-r, --benchmark", "ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨ Ïã§Ìñâ")
	.option("--stats", "ÏÑ±Îä• ÌÜµÍ≥Ñ ÏÉùÏÑ±")
	.option("--file-patterns <patterns>", "ÌååÏùº Ìå®ÌÑ¥ (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)")
	.option("--max-concurrency <number>", "ÏµúÎåÄ ÎèôÏãú Ïã§Ìñâ Ïàò")
	.option("--batch-size <number>", "Î∞∞Ïπò ÌÅ¨Í∏∞")
	.option("--cache-size-limit <bytes>", "Ï∫êÏãú ÌÅ¨Í∏∞ Ï†úÌïú")
	.option("--memory-limit <bytes>", "Î©îÎ™®Î¶¨ Ï†úÌïú")
	.option("--visualization-format <format>", "ÏãúÍ∞ÅÌôî ÌòïÏãù (svg, html, json, dot)")
	.option("--visualization-output <path>", "ÏãúÍ∞ÅÌôî Ï∂úÎ†• Í≤ΩÎ°ú")
	.option("--monitoring-interval <ms>", "Î™®ÎãàÌÑ∞ÎßÅ Í∞ÑÍ≤©")
	.option("--include-memory", "Î©îÎ™®Î¶¨ Ï†ïÎ≥¥ Ìè¨Ìï®")
	.option("--include-cpu", "CPU Ï†ïÎ≥¥ Ìè¨Ìï®")
	.option("--include-cache", "Ï∫êÏãú Ï†ïÎ≥¥ Ìè¨Ìï®")
	.option("--iterations <number>", "Î≤§ÏπòÎßàÌÅ¨ Î∞òÎ≥µ ÌöüÏàò")
	.option("--project-root <path>", "ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ Í≤ΩÎ°ú")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.option("--enable-caching", "Ï∫êÏã± ÌôúÏÑ±Ìôî")
	.option("--enable-batch-processing", "Î∞∞Ïπò Ï≤òÎ¶¨ ÌôúÏÑ±Ìôî")
	.option("--enable-visualization", "ÏãúÍ∞ÅÌôî ÌôúÏÑ±Ìôî")
	.option("--enable-monitoring", "Î™®ÎãàÌÑ∞ÎßÅ ÌôúÏÑ±Ìôî")
	.action(async (options) => {
		const handler = new PerformanceOptimizationHandler({
			projectRoot: options.projectRoot,
			databasePath: options.database,
			enableCaching: options.enableCaching,
			enableBatchProcessing: options.enableBatchProcessing,
			enableVisualization: options.enableVisualization,
			enableMonitoring: options.enableMonitoring,
			maxConcurrency: options.maxConcurrency ? parseInt(options.maxConcurrency) : undefined,
			batchSize: options.batchSize ? parseInt(options.batchSize) : undefined,
			cacheSizeLimit: options.cacheSizeLimit ? parseInt(options.cacheSizeLimit) : undefined,
			memoryLimit: options.memoryLimit ? parseInt(options.memoryLimit) : undefined,
			visualizationFormat: options.visualizationFormat,
			visualizationOutput: options.visualizationOutput,
		});

		try {
			await handler.initialize();

			// ÏµúÏ†ÅÌôîÎêú ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù
			if (options.analyze) {
				await handler.analyzeProject(
					options.analyze,
					options.filePatterns ? options.filePatterns.split(",") : undefined,
					{
						enableCaching: options.enableCaching,
						enableBatchProcessing: options.enableBatchProcessing,
						enableVisualization: options.enableVisualization,
						enableMonitoring: options.enableMonitoring,
					},
				);
			}
			// Ï∫êÏãú Í¥ÄÎ¶¨
			else if (options.cache) {
				await handler.manageCache(options.cache);
			}
			// Î∞∞Ïπò Ï≤òÎ¶¨ Í¥ÄÎ¶¨
			else if (options.batch) {
				await handler.manageBatchProcessing(options.batch, {
					filePaths: options.filePatterns ? options.filePatterns.split(",") : undefined,
					maxConcurrency: options.maxConcurrency ? parseInt(options.maxConcurrency) : undefined,
					batchSize: options.batchSize ? parseInt(options.batchSize) : undefined,
				});
			}
			// ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ
			else if (options.monitor) {
				await handler.startMonitoring({
					interval: options.monitoringInterval ? parseInt(options.monitoringInterval) : undefined,
					includeMemory: options.includeMemory,
					includeCPU: options.includeCPU,
					includeCache: options.includeCache,
				});
			}
			// Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî
			else if (options.optimizeMemory) {
				await handler.optimizeMemory();
			}
			// ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨
			else if (options.benchmark) {
				await handler.runBenchmark({
					iterations: options.iterations ? parseInt(options.iterations) : undefined,
					includeMemory: options.includeMemory,
					includeCPU: options.includeCPU,
					includeCache: options.includeCache,
				});
			}
			// ÏÑ±Îä• ÌÜµÍ≥Ñ
			else if (options.stats) {
				await handler.generateStatistics();
			}
			else {
				console.log("‚ùå Please specify an operation (--analyze, --cache, --batch, --monitor, --optimize-memory, --benchmark, --stats)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Performance Optimization operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// ============================================================================
// RDF File Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("rdf-file")
	.description("RDF Ï£ºÏÜå Í∏∞Î∞ò ÌååÏùº ÏúÑÏπò Î∞òÌôò Î∞è ÌååÏùº Ïó¥Í∏∞")
	.option("-l, --location <rdf-address>", "RDF Ï£ºÏÜåÎ°ú ÌååÏùº ÏúÑÏπò Î∞òÌôò")
	.option("-o, --open <rdf-address>", "RDF Ï£ºÏÜåÎ°ú ÌååÏùº Ïó¥Í∏∞")
	.option("-p, --path <rdf-address>", "RDF Ï£ºÏÜåÎ°ú ÌååÏùº Í≤ΩÎ°ú Î∞òÌôò")
	.option("-r, --relative <rdf-address>", "RDF Ï£ºÏÜåÎ°ú ÏÉÅÎåÄ Í≤ΩÎ°ú Î∞òÌôò")
	.option("-c, --content <rdf-address>", "RDF Ï£ºÏÜåÎ°ú ÌååÏùº ÎÇ¥Ïö© Î∞òÌôò")
	.option("-s, --symbol <rdf-address>", "RDF Ï£ºÏÜåÎ°ú Ïã¨Î≥º Ï†ïÎ≥¥ Î∞òÌôò")
	.option("-e, --exists <rdf-address>", "RDF Ï£ºÏÜåÎ°ú ÌååÏùº Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏")
	.option("-v, --validate <rdf-address>", "RDF Ï£ºÏÜå Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù")
	.option("--editor <editor>", "ÏóêÎîîÌÑ∞ ÏßÄÏ†ï (code, vim, nano, emacs, subl, atom)")
	.option("--line <number>", "ÎùºÏù∏ Î≤àÌò∏")
	.option("--column <number>", "Ïª¨Îüº Î≤àÌò∏")
	.option("--wait", "ÏóêÎîîÌÑ∞ Ï¢ÖÎ£åÍπåÏßÄ ÎåÄÍ∏∞")
	.option("--start-line <number>", "ÌååÏùº ÎÇ¥Ïö© ÏãúÏûë ÎùºÏù∏")
	.option("--end-line <number>", "ÌååÏùº ÎÇ¥Ïö© ÎÅù ÎùºÏù∏")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		const handler = new RDFFileHandler(options.database);

		try {
			// ÌååÏùº ÏúÑÏπò Î∞òÌôò
			if (options.location) {
				const location = await handler.getFileLocation(options.location);
				console.log(`üìÅ RDF Ï£ºÏÜå: ${location.rdfAddress}`);
				console.log(`üìÑ ÌååÏùº Í≤ΩÎ°ú: ${location.filePath}`);
				console.log(`üìç Ï†àÎåÄ Í≤ΩÎ°ú: ${location.absolutePath}`);
				console.log(`üìÇ ÏÉÅÎåÄ Í≤ΩÎ°ú: ${location.relativePath}`);
				console.log(`‚úÖ Ï°¥Ïû¨ Ïó¨Î∂Ä: ${location.exists ? 'Yes' : 'No'}`);
				if (location.lineNumber) {
					console.log(`üìè ÎùºÏù∏ Î≤àÌò∏: ${location.lineNumber}`);
				}
				if (location.columnNumber) {
					console.log(`üìê Ïª¨Îüº Î≤àÌò∏: ${location.columnNumber}`);
				}
			}
			// ÌååÏùº Ïó¥Í∏∞
			else if (options.open) {
				await handler.openFile(options.open, {
					editor: options.editor,
					line: options.line ? parseInt(options.line) : undefined,
					column: options.column ? parseInt(options.column) : undefined,
					wait: options.wait
				});
				console.log(`‚úÖ ÌååÏùº Ïó¥Í∏∞ ÏôÑÎ£å: ${options.open}`);
			}
			// ÌååÏùº Í≤ΩÎ°ú Î∞òÌôò
			else if (options.path) {
				const filePath = await handler.getFilePath(options.path);
				console.log(`üìÑ ÌååÏùº Í≤ΩÎ°ú: ${filePath}`);
			}
			// ÏÉÅÎåÄ Í≤ΩÎ°ú Î∞òÌôò
			else if (options.relative) {
				const relativePath = await handler.getRelativePath(options.relative);
				console.log(`üìÇ ÏÉÅÎåÄ Í≤ΩÎ°ú: ${relativePath}`);
			}
			// ÌååÏùº ÎÇ¥Ïö© Î∞òÌôò
			else if (options.content) {
				const content = await handler.getFileContent(
					options.content,
					options.startLine ? parseInt(options.startLine) : undefined,
					options.endLine ? parseInt(options.endLine) : undefined
				);
				console.log(`üìÑ ÌååÏùº ÎÇ¥Ïö©:`);
				console.log(content);
			}
			// Ïã¨Î≥º Ï†ïÎ≥¥ Î∞òÌôò
			else if (options.symbol) {
				const symbolInfo = await handler.getSymbolInfo(options.symbol);
				console.log(`üîç Ïã¨Î≥º Ï†ïÎ≥¥:`);
				console.log(`  - RDF Ï£ºÏÜå: ${symbolInfo.rdfAddress}`);
				console.log(`  - ÌååÏùº Í≤ΩÎ°ú: ${symbolInfo.filePath}`);
				console.log(`  - Ïã¨Î≥º Ïù¥Î¶Ñ: ${symbolInfo.symbolName}`);
				console.log(`  - Ïã¨Î≥º ÌÉÄÏûÖ: ${symbolInfo.symbolType}`);
				console.log(`  - ÎùºÏù∏ Î≤àÌò∏: ${symbolInfo.lineNumber}`);
				console.log(`  - Ïª¨Îüº Î≤àÌò∏: ${symbolInfo.columnNumber}`);
				console.log(`  - Export Ïó¨Î∂Ä: ${symbolInfo.exported ? 'Yes' : 'No'}`);
				if (symbolInfo.metadata && Object.keys(symbolInfo.metadata).length > 0) {
					console.log(`  - Î©îÌÉÄÎç∞Ïù¥ÌÑ∞: ${JSON.stringify(symbolInfo.metadata, null, 2)}`);
				}
			}
			// ÌååÏùº Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
			else if (options.exists) {
				const exists = await handler.fileExists(options.exists);
				console.log(`‚úÖ ÌååÏùº Ï°¥Ïû¨ Ïó¨Î∂Ä: ${exists ? 'Yes' : 'No'}`);
			}
			// RDF Ï£ºÏÜå Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù
			else if (options.validate) {
				const isValid = await handler.validateRDFAddress(options.validate);
				console.log(`‚úÖ RDF Ï£ºÏÜå Ïú†Ìö®ÏÑ±: ${isValid ? 'Valid' : 'Invalid'}`);
			}
			else {
				console.log("‚ùå Please specify an operation (--location, --open, --path, --relative, --content, --symbol, --exists, --validate)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå RDF File operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Unknown Symbol Í¥ÄÎ¶¨ Î™ÖÎ†πÏñ¥
// ============================================================================
program
	.command("unknown")
	.description("Unknown Symbol Í¥ÄÎ¶¨")
	.option("-r, --register <symbol>", "Unknown Symbol Îì±Î°ù")
	.option("-f, --file <file>", "ÌååÏùº Í≤ΩÎ°ú")
	.option("-s, --search <query>", "Unknown Symbol Í≤ÄÏÉâ")
	.option("-i, --infer", "Ï∂îÎ°† Ïã§Ìñâ")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		const handler = new UnknownSymbolHandler();

		try {
			if (options.register && options.file) {
				await handler.registerUnknownSymbol({
					symbol: options.register,
					file: options.file
				});
				console.log(`‚úÖ Unknown symbol registered: ${options.register}`);
			} else if (options.search) {
				await handler.searchUnknownSymbols(options.search);
				console.log(`üîç Unknown symbol search completed`);
			} else if (options.infer) {
				await handler.applyInferenceRules({ symbol: "test" });
				console.log(`‚úÖ Inference completed`);
			} else {
				console.log("‚ùå Please specify an operation (--register, --search, --infer)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Unknown Symbol operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Query System Í¥ÄÎ¶¨ Î™ÖÎ†πÏñ¥
// ============================================================================
program
	.command("query")
	.description("Query System Í¥ÄÎ¶¨")
	.option("-s, --sql <query>", "SQL ÏøºÎ¶¨ Ïã§Ìñâ")
	.option("-g, --graphql <query>", "GraphQL ÏøºÎ¶¨ Ïã§Ìñâ")
	.option("-n, --natural <query>", "ÏûêÏó∞Ïñ¥ ÏøºÎ¶¨ Ïã§Ìñâ")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		const handler = new QueryHandler(options.database);

		try {
			if (options.sql) {
				const results = await handler.executeSQLQuery(options.sql, {});
				console.log(`‚úÖ SQL query executed: ${results.data.length} results`);
				console.log(JSON.stringify(results.data, null, 2));
			} else if (options.graphql) {
				const results = await handler.executeGraphQLQuery(options.graphql, {});
				console.log(`‚úÖ GraphQL query executed: ${results.data.length} results`);
				console.log(JSON.stringify(results.data, null, 2));
			} else if (options.natural) {
				const results = await handler.executeNaturalLanguageQuery(options.natural, {});
				console.log(`‚úÖ Natural language query executed: ${results.data.length} results`);
				console.log(JSON.stringify(results.data, null, 2));
			} else {
				console.log("‚ùå Please specify a query type (--sql, --graphql, --natural)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Query operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Cross-Namespace Dependencies Í¥ÄÎ¶¨ Î™ÖÎ†πÏñ¥
// ============================================================================
program
	.command("cross-namespace")
	.description("Cross-Namespace Dependencies Í¥ÄÎ¶¨")
	.option("-a, --analyze <namespace1> <namespace2>", "ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Í∞Ñ ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù")
	.option("-c, --circular", "ÏàúÌôò ÏùòÏ°¥ÏÑ± Í≤ÄÏ∂ú")
	.option("-s, --stats", "ÏùòÏ°¥ÏÑ± ÌÜµÍ≥Ñ")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		const handler = new CrossNamespaceHandler(options.database);

		try {
			if (options.analyze) {
				const namespaces = options.analyze.split(' ');
				if (namespaces.length >= 2) {
					await handler.getCrossNamespaceDependencies({
						sourceNamespace: namespaces[0],
						targetNamespace: namespaces[1]
					});
					console.log(`‚úÖ Cross-namespace analysis completed`);
				} else {
					console.log("‚ùå Please provide two namespace names for analysis");
					process.exit(1);
				}
			} else if (options.circular) {
				await handler.getCircularDependencies();
				console.log(`‚úÖ Circular dependency detection completed`);
			} else if (options.stats) {
				await handler.generateStatistics();
				console.log(`‚úÖ Dependency statistics completed`);
			} else {
				console.log("‚ùå Please specify an operation (--analyze, --circular, --stats)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Cross-namespace operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Inference System Í¥ÄÎ¶¨ Î™ÖÎ†πÏñ¥
// ============================================================================
program
	.command("inference")
	.description("Inference System Í¥ÄÎ¶¨")
	.option("-h, --hierarchical <depth>", "Í≥ÑÏ∏µÏ†Å Ï∂îÎ°†")
	.option("-t, --transitive <depth>", "Ï†ÑÏù¥Ï†Å Ï∂îÎ°†")
	.option("-e, --execute <depth>", "Ï∂îÎ°† Ïã§Ìñâ")
	.option("--edge-type <type>", "Ïó£ÏßÄ ÌÉÄÏûÖ")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		const handler = new InferenceHandler(options.database);

		try {
			if (options.hierarchical) {
				const depth = parseInt(options.hierarchical);
				await handler.executeHierarchicalInference(1, options.edgeType || 'imports', {
					maxDepth: depth
				});
				console.log(`‚úÖ Hierarchical inference completed`);
			} else if (options.transitive) {
				const depth = parseInt(options.transitive);
				await handler.executeTransitiveInference(1, options.edgeType || 'depends_on', {
					maxPathLength: depth
				});
				console.log(`‚úÖ Transitive inference completed`);
			} else if (options.execute) {
				const depth = parseInt(options.execute);
				await handler.executeInference(depth);
				console.log(`‚úÖ Inference execution completed`);
			} else {
				console.log("‚ùå Please specify an inference type (--hierarchical, --transitive, --execute)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Inference operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Context Documents Í¥ÄÎ¶¨ Î™ÖÎ†πÏñ¥
// ============================================================================
program
	.command("context-documents")
	.description("Context Documents Í¥ÄÎ¶¨")
	.option("-f, --file <file>", "ÌååÏùº Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏÉùÏÑ±")
	.option("-s, --symbol <file>", "Ïã¨Î≥º Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏÉùÏÑ±")
	.option("--symbol-path <path>", "Ïã¨Î≥º Í≤ΩÎ°ú")
	.option("-p, --project", "ÌîÑÎ°úÏ†ùÌä∏ Ïª®ÌÖçÏä§Ìä∏ Î¨∏ÏÑú ÏÉùÏÑ±")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		const handler = new ContextDocumentsHandler(options.database);

		try {
			if (options.file) {
				await handler.generateFileContext(options.file);
				console.log(`‚úÖ Context document generated for file: ${options.file}`);
			} else if (options.symbol && options.symbolPath) {
				await handler.generateSymbolContext(options.symbol, options.symbolPath);
				console.log(`‚úÖ Symbol context document generated for: ${options.symbolPath}`);
			} else if (options.project) {
				await handler.generateProjectContext();
				console.log(`‚úÖ Project context document generated`);
			} else {
				console.log("‚ùå Please specify an operation (--file, --symbol, --project)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Context Documents operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Performance Optimization Í¥ÄÎ¶¨ Î™ÖÎ†πÏñ¥
// ============================================================================
program
	.command("performance")
	.description("Performance Optimization Í¥ÄÎ¶¨")
	.option("-a, --analyze <project>", "ÏÑ±Îä• Î∂ÑÏÑù")
	.option("-c, --cache <operation>", "Ï∫êÏãú Í¥ÄÎ¶¨")
	.option("-b, --batch <operation>", "Î∞∞Ïπò Ï≤òÎ¶¨ Í¥ÄÎ¶¨")
	.option("-m, --monitor", "ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ")
	.option("--optimize-memory", "Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî")
	.option("--benchmark", "ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨")
	.option("-s, --stats", "ÏÑ±Îä• ÌÜµÍ≥Ñ")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		const handler = new PerformanceOptimizationHandler(options.database);

		try {
			if (options.analyze) {
				await handler.analyzeProject(options.analyze);
				console.log(`‚úÖ Performance analysis completed for project: ${options.analyze}`);
			} else if (options.cache) {
				await handler.manageCache(options.cache as "clear" | "stats" | "optimize");
				console.log(`‚úÖ Cache management completed`);
			} else if (options.batch) {
				await handler.manageBatchProcessing(options.batch as "start" | "stop" | "stats" | "retry");
				console.log(`‚úÖ Batch processing management completed`);
			} else if (options.monitor) {
				await handler.startMonitoring();
				console.log(`‚úÖ Performance monitoring started`);
			} else if (options.optimizeMemory) {
				await handler.optimizeMemory();
				console.log(`‚úÖ Memory optimization completed`);
			} else if (options.benchmark) {
				await handler.runBenchmark();
				console.log(`‚úÖ Performance benchmark completed`);
			} else if (options.stats) {
				await handler.generateStatistics();
				console.log(`‚úÖ Performance statistics generated`);
			} else {
				console.log("‚ùå Please specify an operation (--analyze, --cache, --batch, --monitor, --optimize-memory, --benchmark, --stats)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Performance operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Markdown Î∂ÑÏÑù Î™ÖÎ†πÏñ¥
// ============================================================================
program
	.command("markdown")
	.description("Markdown analysis commands")
	.option("-a, --analyze <file>", "Markdown ÌååÏùº Î∂ÑÏÑù")
	.option("-t, --track-links <file>", "ÎßÅÌÅ¨ Ï∂îÏ†Å")
	.option("-e, --extract-headings <file>", "Ìó§Îî© Ï∂îÏ∂ú")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		try {
			if (options.analyze) {
				await runMarkdownAnalysis(options.analyze);
				console.log(`‚úÖ Markdown analysis completed for: ${options.analyze}`);
			} else if (options.trackLinks) {
				await runLinkTracking(options.trackLinks);
				console.log(`‚úÖ Link tracking completed for: ${options.trackLinks}`);
			} else if (options.extractHeadings) {
				await runHeadingExtraction(options.extractHeadings);
				console.log(`‚úÖ Heading extraction completed for: ${options.extractHeadings}`);
			} else {
				console.log("‚ùå Please specify an operation (--analyze, --track-links, --extract-headings)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Markdown operation failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// TypeScript Î∂ÑÏÑù Î™ÖÎ†πÏñ¥
// ============================================================================
program
	.command("typescript")
	.description("TypeScript analysis commands")
	.option("-a, --analyze <file>", "TypeScript ÌååÏùº Î∂ÑÏÑù")
	.option("-p, --project <dir>", "TypeScript ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù")
	.option("-b, --benchmark", "ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		try {
			if (options.analyze) {
				await runTypeScriptAnalysis(options.analyze, {});
				console.log(`‚úÖ TypeScript analysis completed for: ${options.analyze}`);
			} else if (options.project) {
				await runTypeScriptProjectAnalysis(options.project, {});
				console.log(`‚úÖ TypeScript project analysis completed for: ${options.project}`);
			} else if (options.benchmark) {
				await runTypeScriptPerformanceBenchmark("benchmark");
				console.log(`‚úÖ TypeScript benchmark completed`);
			} else {
				console.log("‚ùå Please specify an operation (--analyze, --project, --benchmark)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå TypeScript operation failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// Namespace Í¥ÄÎ¶¨ Î™ÖÎ†πÏñ¥
// ============================================================================
program
	.command("namespace")
	.description("Namespace management")
	.option("-a, --analyze", "ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù")
	.option("-o, --optimize", "ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÏµúÏ†ÅÌôî")
	.option("-s, --stats", "ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÌÜµÍ≥Ñ")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		try {
			if (options.analyze) {
				await runNamespaceAnalysis();
				console.log(`‚úÖ Namespace analysis completed`);
			} else if (options.optimize) {
				const optimizer = new NamespaceOptimizer();
				await optimizer.optimizeNamespaces({} as any);
				console.log(`‚úÖ Namespace optimization completed`);
			} else if (options.stats) {
				await runNamespaceAnalysis();
				console.log(`‚úÖ Namespace statistics completed`);
			} else {
				console.log("‚ùå Please specify an operation (--analyze, --optimize, --stats)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Namespace operation failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// Benchmark Î™ÖÎ†πÏñ¥
// ============================================================================
program
	.command("benchmark")
	.description("Performance benchmark")
	.option("-f, --file <file>", "ÌååÏùº Î≤§ÏπòÎßàÌÅ¨")
	.option("-i, --iterations <number>", "Î∞òÎ≥µ ÌöüÏàò")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.action(async (options) => {
		try {
			if (options.file) {
				const iterations = options.iterations ? parseInt(options.iterations) : 3;
				await runTypeScriptPerformanceBenchmark("benchmark");
				console.log(`‚úÖ Benchmark completed for: ${options.file}`);
				console.log(`  - Iterations: ${iterations}`);
			} else {
				console.log("‚ùå Please specify a file (--file)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Benchmark operation failed:", error);
			process.exit(1);
		}
	});

// ÌîÑÎ°úÍ∑∏Îû® Ïã§Ìñâ
// ============================================================================

program.parse();
