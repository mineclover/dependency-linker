/**
 * Clean CLI Entry Point
 * Ìï∏Îì§Îü¨ Í∏∞Î∞ò ÏïÑÌÇ§ÌÖçÏ≤òÎ°ú Íµ¨ÏÑ±Îêú ÍπîÎÅîÌïú CLI
 */

import { Command } from "commander";
import { glob } from "glob";

// Ìï∏Îì§Îü¨ ÏûÑÌè¨Ìä∏
import {
	runMarkdownAnalysis,
	runLinkTracking,
	runHeadingExtraction,
	runTagCollection,
	runTagHeadingMapping,
	runTagDocumentGeneration,
	runTagTypeValidation,
	runTagTypeDocumentGeneration,
} from "./handlers/markdown-handler.js";
import {
	runTypeScriptAnalysis,
	runTypeScriptProjectAnalysis,
	runTypeScriptPerformanceBenchmark,
} from "./handlers/typescript-handler.js";
import { RDFHandler, UnknownSymbolHandler, QueryHandler, CrossNamespaceHandler, InferenceHandler, HandlerFactory } from "./handlers/index.js";

// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∞è RDF Í¥ÄÎ†® ÏûÑÌè¨Ìä∏
import {
	runNamespaceAnalysis,
} from "../namespace/analysis-namespace.js";
import {
	createRDFAddress,
	validateRDFAddress,
} from "../core/RDFAddress.js";
import { RDFDatabaseAPI } from "../api/rdf-database-integration.js";

// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÏµúÏ†ÅÌôî
import { NamespaceOptimizer } from "../cli/namespace-optimizer.js";

const program = new Command();

program
	.name("dependency-linker")
	.description("Advanced dependency analysis tool")
	.version("2.1.0");

// ============================================================================
// Í∏∞Î≥∏ Î∂ÑÏÑù Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("analyze")
	.description("Analyze files for dependencies")
	.option("-p, --pattern <pattern>", "File pattern to analyze", "src/**/*.ts")
	.option("-d, --directory <dir>", "Directory to analyze", ".")
	.option("-t, --type <type>", "Analysis type", "fixed")
	.option("--performance", "Enable performance optimizations")
	.option("--max-concurrency <num>", "Max concurrent files", "4")
	.option("--batch-size <num>", "Batch size for processing", "10")
	.option("--memory-limit <mb>", "Memory limit in MB", "1024")
	.option("-o, --output <file>", "Output file")
	.option("--format <format>", "Output format", "json")
	.option("--include-statistics", "Include detailed statistics")
	.action(async (options) => {
		try {
			console.log("üîç Running analysis...\n");

			// ÌååÏùº Ìå®ÌÑ¥ÏúºÎ°ú ÌååÏùº Ï∞æÍ∏∞
			const files = await glob(options.pattern, { cwd: options.directory });

			if (files.length === 0) {
				console.log("‚ùå No files found matching the pattern");
				return;
			}

			console.log(`üìÅ Found ${files.length} files to analyze`);

			// TypeScript ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù Ïã§Ìñâ
			await runTypeScriptProjectAnalysis(options.pattern, {
				performance: options.performance,
				maxConcurrency: options.maxConcurrency,
				batchSize: options.batchSize,
				memoryLimit: options.memoryLimit,
				output: options.output,
				format: options.format,
				includeStatistics: options.includeStatistics,
			});

			console.log(`\n‚úÖ Analysis completed`);
		} catch (error) {
			console.error("‚ùå Analysis failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// ÎßàÌÅ¨Îã§Ïö¥ Î∂ÑÏÑù Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("markdown")
	.description("Markdown analysis commands")
	.option("-n, --name <namespace>", "Namespace name")
	.option("-a, --action <action>", "Action to perform", "analysis")
	.action(async (options) => {
		if (!options.name) {
			console.log("‚ùå Please specify --name <namespace>");
			process.exit(1);
		}

		try {
			switch (options.action) {
				case "analysis":
					await runMarkdownAnalysis(options.name);
					break;
				case "links":
					await runLinkTracking(options.name);
					break;
				case "headings":
					await runHeadingExtraction(options.name);
					break;
				case "tags":
					await runTagCollection(options.name);
					break;
				case "mapping":
					await runTagHeadingMapping(options.name);
					break;
				case "document":
					await runTagDocumentGeneration(options.name);
					break;
				case "validation":
					await runTagTypeValidation(options.name);
					break;
				case "type-doc":
					await runTagTypeDocumentGeneration(options.name);
					break;
				default:
					console.log(
						"‚ùå Unknown action. Available: analysis, links, headings, tags, mapping, document, validation, type-doc",
					);
					process.exit(1);
			}
		} catch (error) {
			console.error(`‚ùå Markdown ${options.action} failed:`, error);
			process.exit(1);
		}
	});

// ============================================================================
// TypeScript Î∂ÑÏÑù Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("typescript")
	.description("TypeScript analysis commands")
	.option("-f, --file <file>", "File to analyze")
	.option("-p, --pattern <pattern>", "File pattern to analyze")
	.option("-t, --type <type>", "Analysis type", "fixed")
	.option("--performance", "Enable performance optimizations")
	.option("-o, --output <file>", "Output file")
	.option("--format <format>", "Output format", "json")
	.option("--include-statistics", "Include detailed statistics")
	.action(async (options) => {
		try {
			if (options.file) {
				// Îã®Ïùº ÌååÏùº Î∂ÑÏÑù
				await runTypeScriptAnalysis(options.file, {
					analysisType: options.type,
					performance: options.performance,
					output: options.output,
					format: options.format,
					includeStatistics: options.includeStatistics,
				});
			} else if (options.pattern) {
				// Ìå®ÌÑ¥ Í∏∞Î∞ò Î∂ÑÏÑù
				await runTypeScriptProjectAnalysis(options.pattern, {
					performance: options.performance,
					output: options.output,
					format: options.format,
					includeStatistics: options.includeStatistics,
				});
			} else {
				console.log("‚ùå Please specify either --file or --pattern");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå TypeScript analysis failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨ Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("benchmark")
	.description("Performance benchmark")
	.option("-n, --name <name>", "Benchmark name", "default")
	.option("-t, --type <type>", "Benchmark type", "typescript")
	.action(async (options) => {
		try {
			if (options.type === "typescript") {
				await runTypeScriptPerformanceBenchmark(options.name);
			} else {
				console.log("‚ùå Unknown benchmark type. Available: typescript");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Benchmark failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Í¥ÄÎ¶¨ Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("namespace")
	.description("Namespace management")
	.option("-l, --list", "List namespaces")
	.option("-n, --name <name>", "Namespace name")
	.option("-a, --all", "Run all namespaces")
	.option("-o, --optimize", "Optimize namespace")
	.action(async (options) => {
		try {
			if (options.list) {
				console.log("üìã Available namespaces:");
				console.log("   - source: Source code analysis");
				console.log("   - markdown: Markdown analysis");
				console.log("   - typescript: TypeScript analysis");
			} else if (options.name) {
				await runNamespaceAnalysis(options.name);
			} else if (options.all) {
				const namespaces = ["source", "markdown", "typescript"];
				for (const ns of namespaces) {
					console.log(`\nüîÑ Running namespace: ${ns}`);
					await runNamespaceAnalysis(ns);
				}
			} else if (options.optimize) {
				console.log("üîß Namespace optimization is not yet implemented");
			} else {
				console.log(
					"‚ùå Please specify an action: --list, --name, --all, or --optimize",
				);
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Namespace operation failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// RDF Í¥ÄÎ†® Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("rdf")
	.description("RDF operations")
	.option("-c, --create", "Create RDF address")
	.option("-p, --project <project>", "Project name")
	.option("-f, --file <file>", "File path")
	.option("-t, --type <type>", "Node type")
	.option("-s, --symbol <symbol>", "Symbol name")
	.option("-q, --query <query>", "Search query")
	.option("-n, --namespace <namespace>", "Namespace name")
	.option("-v, --validate", "Validate RDF address")
	.option("-a, --address <address>", "RDF address to validate")
	.option("--uniqueness", "Check uniqueness")
	.option("--stats", "Show RDF statistics")
	.option("--by-type", "Group statistics by type")
	.option("--all", "Show all statistics")
	.action(async (options) => {
		const handler = new RDFHandler();
		try {
			// RDF Ï£ºÏÜå ÏÉùÏÑ±
			if (options.create) {
				if (!options.project || !options.file || !options.type || !options.symbol) {
					console.log("‚ùå Please specify --project, --file, --type, and --symbol");
					process.exit(1);
				}
				await handler.createRDFAddress({
					project: options.project,
					file: options.file,
					type: options.type,
					symbol: options.symbol
				});
			}
			// RDF Ï£ºÏÜå Í≤ÄÏÉâ
			else if (options.query) {
				await handler.searchRDFAddresses({
					query: options.query,
					namespace: options.namespace,
					project: options.project,
					file: options.file,
					type: options.type
				});
			}
			// RDF Ï£ºÏÜå Í≤ÄÏ¶ù
			else if (options.validate) {
				await handler.validateRDFAddress({
					address: options.address,
					namespace: options.namespace,
					uniqueness: options.uniqueness
				});
			}
			// RDF ÌÜµÍ≥Ñ
			else if (options.stats) {
				await handler.generateRDFStatistics({
					namespace: options.namespace,
					project: options.project,
					all: options.all,
					byType: options.byType
				});
			}
			else {
				console.log("‚ùå Please specify an RDF operation (--create, --query, --validate, --stats)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå RDF operation failed:", error);
			process.exit(1);
		}
	});

// ============================================================================
// Unknown Symbol Í¥ÄÎ¶¨ Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("unknown")
	.description("Unknown Symbol Í¥ÄÎ¶¨")
	.option("-r, --register", "Unknown Symbol Îì±Î°ù")
	.option("-f, --file <file>", "ÌååÏùº Í≤ΩÎ°ú")
	.option("-s, --symbol <symbol>", "Ïã¨Î≥º Ïù¥Î¶Ñ")
	.option("-t, --type <type>", "Ïã¨Î≥º ÌÉÄÏûÖ")
	.option("--imported", "ImportÎêú Ïã¨Î≥º")
	.option("--alias", "Alias Ïã¨Î≥º")
	.option("--original <name>", "ÏõêÎ≥∏ Ïã¨Î≥º Ïù¥Î¶Ñ")
	.option("--from <file>", "ImportÎêú ÌååÏùº")
	.option("-q, --query <query>", "Í≤ÄÏÉâ ÏøºÎ¶¨")
	.option("--candidates", "ÎèôÎì±ÏÑ± ÌõÑÎ≥¥ Í≤ÄÏÉâ")
	.option("--equivalence", "ÎèôÎì±ÏÑ± Í¥ÄÍ≥Ñ ÏÉùÏÑ±")
	.option("--unknown-id <id>", "Unknown Symbol ID")
	.option("--known-id <id>", "Known Symbol ID")
	.option("--confidence <number>", "Ïã†Î¢∞ÎèÑ (0-1)")
	.option("--match-type <type>", "Îß§Ïπ≠ ÌÉÄÏûÖ")
	.option("--infer", "Ï∂îÎ°† Í∑úÏπô Ï†ÅÏö©")
	.option("--list", "ÎèôÎì±ÏÑ± Í¥ÄÍ≥Ñ Ï°∞Ìöå")
	.option("--stats", "ÌÜµÍ≥Ñ ÏÉùÏÑ±")
	.action(async (options) => {
		const handler = new UnknownSymbolHandler();
		try {
			// Unknown Symbol Îì±Î°ù
			if (options.register) {
				if (!options.file || !options.symbol) {
					console.log("‚ùå Please specify --file and --symbol");
					process.exit(1);
				}
				await handler.registerUnknownSymbol({
					file: options.file,
					symbol: options.symbol,
					type: options.type,
					isImported: options.imported,
					isAlias: options.alias,
					originalName: options.original,
					importedFrom: options.from
				});
			}
			// Unknown Symbol Í≤ÄÏÉâ
			else if (options.query) {
				await handler.searchUnknownSymbols({
					query: options.query,
					type: options.type,
					file: options.file
				});
			}
			// ÎèôÎì±ÏÑ± ÌõÑÎ≥¥ Í≤ÄÏÉâ
			else if (options.candidates) {
				if (!options.symbol) {
					console.log("‚ùå Please specify --symbol");
					process.exit(1);
				}
				await handler.searchEquivalenceCandidates({
					symbol: options.symbol,
					type: options.type,
					file: options.file
				});
			}
			// ÎèôÎì±ÏÑ± Í¥ÄÍ≥Ñ ÏÉùÏÑ±
			else if (options.equivalence) {
				if (!options.unknownId || !options.knownId) {
					console.log("‚ùå Please specify --unknown-id and --known-id");
					process.exit(1);
				}
				await handler.createEquivalenceRelation({
					unknownId: options.unknownId,
					knownId: options.knownId,
					confidence: options.confidence ? parseFloat(options.confidence) : undefined,
					matchType: options.matchType
				});
			}
			// Ï∂îÎ°† Í∑úÏπô Ï†ÅÏö©
			else if (options.infer) {
				if (!options.symbol) {
					console.log("‚ùå Please specify --symbol");
					process.exit(1);
				}
				await handler.applyInferenceRules({
					symbol: options.symbol,
					type: options.type,
					file: options.file
				});
			}
			// ÎèôÎì±ÏÑ± Í¥ÄÍ≥Ñ Ï°∞Ìöå
			else if (options.list) {
				await handler.listEquivalenceRelations({
					symbol: options.symbol,
					type: options.type,
					file: options.file
				});
			}
			// ÌÜµÍ≥Ñ ÏÉùÏÑ±
			else if (options.stats) {
				await handler.generateStatistics();
			}
			else {
				console.log("‚ùå Please specify an Unknown Symbol operation (--register, --query, --candidates, --equivalence, --infer, --list, --stats)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Unknown Symbol operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Query System Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("query")
	.description("Query System Í¥ÄÎ¶¨")
	.option("-s, --sql <query>", "SQL ÏøºÎ¶¨ Ïã§Ìñâ")
	.option("-g, --graphql <query>", "GraphQL ÏøºÎ¶¨ Ïã§Ìñâ")
	.option("-n, --natural <query>", "ÏûêÏó∞Ïñ¥ ÏøºÎ¶¨ Ïã§Ìñâ")
	.option("-a, --auto <query>", "ÏûêÎèô ÏøºÎ¶¨ ÌÉÄÏûÖ Í∞êÏßÄ Î∞è Ïã§Ìñâ")
	.option("-r, --realtime", "Ïã§ÏãúÍ∞Ñ ÏøºÎ¶¨ Îì±Î°ù")
	.option("--query-type <type>", "ÏøºÎ¶¨ ÌÉÄÏûÖ (SQL, GraphQL, NaturalLanguage)")
	.option("--client-id <id>", "ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID")
	.option("--subscribe", "Ïã§ÏãúÍ∞Ñ ÏøºÎ¶¨ Íµ¨ÎèÖ")
	.option("--query-id <id>", "ÏøºÎ¶¨ ID")
	.option("--event-type <type>", "Ïù¥Î≤§Ìä∏ ÌÉÄÏûÖ (data, error, complete)")
	.option("--stats", "ÏøºÎ¶¨ ÏÑ±Îä• ÌÜµÍ≥Ñ")
	.option("--cache <action>", "Ï∫êÏãú Í¥ÄÎ¶¨ (clear, stats, optimize)")
	.option("--data-source <source>", "Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§")
	.action(async (options) => {
		const handler = new QueryHandler();
		try {
			await handler.initialize();

			// SQL ÏøºÎ¶¨ Ïã§Ìñâ
			if (options.sql) {
				await handler.executeSQLQuery(options.sql, options.dataSource || {});
			}
			// GraphQL ÏøºÎ¶¨ Ïã§Ìñâ
			else if (options.graphql) {
				await handler.executeGraphQLQuery(options.graphql, options.dataSource || {});
			}
			// ÏûêÏó∞Ïñ¥ ÏøºÎ¶¨ Ïã§Ìñâ
			else if (options.natural) {
				await handler.executeNaturalLanguageQuery(options.natural, options.dataSource || {});
			}
			// ÏûêÎèô ÏøºÎ¶¨ Ïã§Ìñâ
			else if (options.auto) {
				await handler.executeQuery(options.auto, options.dataSource || {});
			}
			// Ïã§ÏãúÍ∞Ñ ÏøºÎ¶¨ Îì±Î°ù
			else if (options.realtime) {
				if (!options.queryType || !options.clientId) {
					console.log("‚ùå Please specify --query-type and --client-id");
					process.exit(1);
				}
				await handler.registerRealtimeQuery(
					options.auto || options.sql || options.graphql || options.natural,
					options.queryType,
					options.clientId,
					options.dataSource || {}
				);
			}
			// Ïã§ÏãúÍ∞Ñ ÏøºÎ¶¨ Íµ¨ÎèÖ
			else if (options.subscribe) {
				if (!options.queryId || !options.clientId || !options.eventType) {
					console.log("‚ùå Please specify --query-id, --client-id, and --event-type");
					process.exit(1);
				}
				await handler.subscribeToRealtimeQuery(
					options.queryId,
					options.clientId,
					options.eventType
				);
			}
			// ÏøºÎ¶¨ ÌÜµÍ≥Ñ
			else if (options.stats) {
				await handler.getQueryStatistics();
			}
			// Ï∫êÏãú Í¥ÄÎ¶¨
			else if (options.cache) {
				await handler.manageCache(options.cache);
			}
			else {
				console.log("‚ùå Please specify a query operation (--sql, --graphql, --natural, --auto, --realtime, --subscribe, --stats, --cache)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Query operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Cross-Namespace Dependencies Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("cross-namespace")
	.description("Cross-Namespace Dependencies Í¥ÄÎ¶¨")
	.option("-n, --namespace <name>", "Îã®Ïùº ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù")
	.option("-m, --multiple <names>", "Îã§Ï§ë ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)")
	.option("-a, --all", "Ï†ÑÏ≤¥ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù")
	.option("-c, --cross", "Cross-Namespace ÏùòÏ°¥ÏÑ± Ï°∞Ìöå")
	.option("-s, --source <namespace>", "ÏÜåÏä§ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÌïÑÌÑ∞")
	.option("-t, --target <namespace>", "ÌÉÄÍ≤ü ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÌïÑÌÑ∞")
	.option("--circular", "ÏàúÌôò ÏùòÏ°¥ÏÑ± Ï°∞Ìöå")
	.option("--circular-namespace <name>", "ÌäπÏ†ï ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÏàúÌôò ÏùòÏ°¥ÏÑ± Ï°∞Ìöå")
	.option("--stats", "ÌÜµÍ≥Ñ ÏÉùÏÑ±")
	.option("--include-cross", "Cross-Namespace ÏùòÏ°¥ÏÑ± Ìè¨Ìï®")
	.option("--include-circular", "ÏàúÌôò ÏùòÏ°¥ÏÑ± Ìè¨Ìï®")
	.option("--include-graph", "Í∑∏ÎûòÌîÑ ÌÜµÍ≥Ñ Ìè¨Ìï®")
	.option("--config <path>", "ÏÑ§Ï†ï ÌååÏùº Í≤ΩÎ°ú")
	.option("--project-root <path>", "ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ Í≤ΩÎ°ú")
	.option("--cwd <path>", "ÏûëÏóÖ ÎîîÎ†âÌÜ†Î¶¨")
	.option("--max-concurrency <number>", "ÏµúÎåÄ ÎèôÏãú Ïã§Ìñâ Ïàò")
	.option("--enable-caching", "Ï∫êÏã± ÌôúÏÑ±Ìôî")
	.action(async (options) => {
		const handler = new CrossNamespaceHandler({
			configPath: options.config,
			projectRoot: options.projectRoot,
			cwd: options.cwd,
			maxConcurrency: options.maxConcurrency ? parseInt(options.maxConcurrency) : undefined,
			enableCaching: options.enableCaching,
		});

		try {
			await handler.initialize();

			// Îã®Ïùº ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù
			if (options.namespace) {
				await handler.analyzeNamespace(options.namespace, {
					includeCrossDependencies: options.includeCross,
					includeCircularDependencies: options.includeCircular,
				});
			}
			// Îã§Ï§ë ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù
			else if (options.multiple) {
				const namespaces = options.multiple.split(",").map((n: string) => n.trim());
				await handler.analyzeNamespaces(namespaces, {
					includeCrossDependencies: options.includeCross,
					includeStatistics: options.stats,
				});
			}
			// Ï†ÑÏ≤¥ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î∂ÑÏÑù
			else if (options.all) {
				await handler.analyzeAll({
					includeGraph: options.includeGraph,
					includeCrossDependencies: options.includeCross,
					includeStatistics: options.stats,
				});
			}
			// Cross-Namespace ÏùòÏ°¥ÏÑ± Ï°∞Ìöå
			else if (options.cross) {
				await handler.getCrossNamespaceDependencies({
					sourceNamespace: options.source,
					targetNamespace: options.target,
					includeStatistics: options.stats,
				});
			}
			// ÏàúÌôò ÏùòÏ°¥ÏÑ± Ï°∞Ìöå
			else if (options.circular) {
				await handler.getCircularDependencies(options.circularNamespace, {
					includeStatistics: options.stats,
				});
			}
			// ÌÜµÍ≥Ñ ÏÉùÏÑ±
			else if (options.stats) {
				await handler.generateStatistics({
					includeCrossDependencies: options.includeCross,
					includeCircularDependencies: options.includeCircular,
					includeGraphStatistics: options.includeGraph,
				});
			}
			else {
				console.log("‚ùå Please specify an operation (--namespace, --multiple, --all, --cross, --circular, --stats)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Cross-Namespace operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// Inference System Î™ÖÎ†πÏñ¥
// ============================================================================

program
	.command("inference")
	.description("Inference System Í¥ÄÎ¶¨")
	.option("-e, --execute <nodeId>", "ÌÜµÌï© Ï∂îÎ°† Ïã§Ìñâ")
	.option("-h, --hierarchical <nodeId>", "Í≥ÑÏ∏µÏ†Å Ï∂îÎ°† Ïã§Ìñâ")
	.option("-t, --transitive <nodeId>", "Ï†ÑÏù¥Ï†Å Ï∂îÎ°† Ïã§Ìñâ")
	.option("-i, --inheritable <nodeId>", "ÏÉÅÏÜç Í∞ÄÎä•Ìïú Ï∂îÎ°† Ïã§Ìñâ")
	.option("-o, --optimized <nodeId>", "ÏµúÏ†ÅÌôîÎêú Ï∂îÎ°† Ïã§Ìñâ")
	.option("-r, --realtime <nodeId>", "Ïã§ÏãúÍ∞Ñ Ï∂îÎ°† Ïã§Ìñâ")
	.option("-a, --all <nodeId>", "Î™®Îì† Ï∂îÎ°† Ïã§Ìñâ")
	.option("--edge-type <type>", "Ïó£ÏßÄ ÌÉÄÏûÖ")
	.option("--rule-ids <ids>", "Í∑úÏπô ID Î™©Î°ù (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)")
	.option("--include-children", "ÏûêÏãù ÎÖ∏Îìú Ìè¨Ìï®")
	.option("--max-depth <depth>", "ÏµúÎåÄ ÍπäÏù¥")
	.option("--max-path-length <length>", "ÏµúÎåÄ Í≤ΩÎ°ú Í∏∏Ïù¥")
	.option("--include-intermediate", "Ï§ëÍ∞Ñ ÎÖ∏Îìú Ìè¨Ìï®")
	.option("--include-inherited", "ÏÉÅÏÜçÎêú Í¥ÄÍ≥Ñ Ìè¨Ìï®")
	.option("--max-inheritance-depth <depth>", "ÏµúÎåÄ ÏÉÅÏÜç ÍπäÏù¥")
	.option("--enable-caching", "Ï∫êÏã± ÌôúÏÑ±Ìôî")
	.option("--enable-parallel", "Î≥ëÎ†¨ Ï≤òÎ¶¨ ÌôúÏÑ±Ìôî")
	.option("--max-concurrency <number>", "ÏµúÎåÄ ÎèôÏãú Ïã§Ìñâ Ïàò")
	.option("--enable-auto-inference", "ÏûêÎèô Ï∂îÎ°† ÌôúÏÑ±Ìôî")
	.option("--use-custom-rules", "ÏÇ¨Ïö©Ïûê Ï†ïÏùò Í∑úÏπô ÏÇ¨Ïö©")
	.option("--use-realtime", "Ïã§ÏãúÍ∞Ñ Ï∂îÎ°† ÏÇ¨Ïö©")
	.option("--use-optimized", "ÏµúÏ†ÅÌôîÎêú Ï∂îÎ°† ÏÇ¨Ïö©")
	.option("--use-legacy", "Î†àÍ±∞Ïãú Ï∂îÎ°† ÏÇ¨Ïö©")
	.option("--stats", "Ï∂îÎ°† ÌÜµÍ≥Ñ ÏÉùÏÑ±")
	.option("--cache <action>", "Ï∫êÏãú Í¥ÄÎ¶¨ (clear, stats, optimize)")
	.option("--database <path>", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú")
	.option("--enable-custom-rules", "ÏÇ¨Ïö©Ïûê Ï†ïÏùò Í∑úÏπô ÌôúÏÑ±Ìôî")
	.option("--enable-realtime-inference", "Ïã§ÏãúÍ∞Ñ Ï∂îÎ°† ÌôúÏÑ±Ìôî")
	.option("--enable-optimized-inference", "ÏµúÏ†ÅÌôîÎêú Ï∂îÎ°† ÌôúÏÑ±Ìôî")
	.option("--enable-legacy-inference", "Î†àÍ±∞Ïãú Ï∂îÎ°† ÌôúÏÑ±Ìôî")
	.action(async (options) => {
		const handler = new InferenceHandler({
			databasePath: options.database,
			enableCustomRules: options.enableCustomRules,
			enableRealTimeInference: options.enableRealtimeInference,
			enableOptimizedInference: options.enableOptimizedInference,
			enableLegacyInference: options.enableLegacyInference,
			maxConcurrency: options.maxConcurrency ? parseInt(options.maxConcurrency) : undefined,
			enableCaching: options.enableCaching,
		});

		try {
			await handler.initialize();

			// ÌÜµÌï© Ï∂îÎ°† Ïã§Ìñâ
			if (options.execute) {
				const nodeId = parseInt(options.execute);
				await handler.executeInference(nodeId, {
					ruleIds: options.ruleIds ? options.ruleIds.split(",") : undefined,
					useCustomRules: options.useCustomRules,
					useRealTime: options.useRealtime,
					useOptimized: options.useOptimized,
					useLegacy: options.useLegacy,
				});
			}
			// Í≥ÑÏ∏µÏ†Å Ï∂îÎ°† Ïã§Ìñâ
			else if (options.hierarchical) {
				const nodeId = parseInt(options.hierarchical);
				if (!options.edgeType) {
					console.log("‚ùå Please specify --edge-type for hierarchical inference");
					process.exit(1);
				}
				await handler.executeHierarchicalInference(nodeId, options.edgeType, {
					includeChildren: options.includeChildren,
					maxDepth: options.maxDepth ? parseInt(options.maxDepth) : undefined,
				});
			}
			// Ï†ÑÏù¥Ï†Å Ï∂îÎ°† Ïã§Ìñâ
			else if (options.transitive) {
				const nodeId = parseInt(options.transitive);
				if (!options.edgeType) {
					console.log("‚ùå Please specify --edge-type for transitive inference");
					process.exit(1);
				}
				await handler.executeTransitiveInference(nodeId, options.edgeType, {
					maxPathLength: options.maxPathLength ? parseInt(options.maxPathLength) : undefined,
					includeIntermediate: options.includeIntermediate,
				});
			}
			// ÏÉÅÏÜç Í∞ÄÎä•Ìïú Ï∂îÎ°† Ïã§Ìñâ
			else if (options.inheritable) {
				const nodeId = parseInt(options.inheritable);
				if (!options.edgeType) {
					console.log("‚ùå Please specify --edge-type for inheritable inference");
					process.exit(1);
				}
				await handler.executeInheritableInference(nodeId, options.edgeType, {
					includeInherited: options.includeInherited,
					maxInheritanceDepth: options.maxInheritanceDepth ? parseInt(options.maxInheritanceDepth) : undefined,
				});
			}
			// ÏµúÏ†ÅÌôîÎêú Ï∂îÎ°† Ïã§Ìñâ
			else if (options.optimized) {
				const nodeId = parseInt(options.optimized);
				await handler.executeOptimizedInference(nodeId, {
					enableCaching: options.enableCaching,
					enableParallel: options.enableParallel,
					maxConcurrency: options.maxConcurrency ? parseInt(options.maxConcurrency) : undefined,
				});
			}
			// Ïã§ÏãúÍ∞Ñ Ï∂îÎ°† Ïã§Ìñâ
			else if (options.realtime) {
				const nodeId = parseInt(options.realtime);
				await handler.executeRealTimeInference(nodeId, {
					ruleIds: options.ruleIds ? options.ruleIds.split(",") : undefined,
					enableAutoInference: options.enableAutoInference,
				});
			}
			// Î™®Îì† Ï∂îÎ°† Ïã§Ìñâ
			else if (options.all) {
				const nodeId = parseInt(options.all);
				await handler.executeAllInferences(nodeId, {
					includeCustomRules: options.useCustomRules,
					includeRealTime: options.useRealtime,
					includeOptimized: options.useOptimized,
					includeLegacy: options.useLegacy,
				});
			}
			// Ï∂îÎ°† ÌÜµÍ≥Ñ
			else if (options.stats) {
				await handler.generateStatistics();
			}
			// Ï∫êÏãú Í¥ÄÎ¶¨
			else if (options.cache) {
				await handler.manageCache(options.cache);
			}
			else {
				console.log("‚ùå Please specify an inference operation (--execute, --hierarchical, --transitive, --inheritable, --optimized, --realtime, --all, --stats, --cache)");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Inference operation failed:", error);
			process.exit(1);
		} finally {
			await handler.close();
		}
	});

// ============================================================================
// ÌîÑÎ°úÍ∑∏Îû® Ïã§Ìñâ
// ============================================================================

program.parse();
