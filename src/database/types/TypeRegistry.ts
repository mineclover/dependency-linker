/**
 * Type Registry System
 *
 * Centralized type definitions and validation for GraphDB nodes and edges.
 * Types represent the actual data shape extracted from AST parsing.
 * Semantic tags are separate metadata generated by extraction rules.
 */

/**
 * Node Type Enumeration
 * Defines all valid node types in the graph database
 */
export enum NodeType {
	// ===== File & Resource Types =====
	/** Source code file */
	File = "file",
	/** External resource (URL, etc.) */
	ExternalResource = "external-resource",
	/** Missing/broken file reference */
	MissingFile = "missing-file",
	/** External library */
	Library = "library",
	/** NPM package */
	Package = "package",

	// ===== Code Symbol Types (LSP-based) =====
	/** Class definition */
	Class = "class",
	/** Interface definition */
	Interface = "interface",
	/** Function definition */
	Function = "function",
	/** Method definition */
	Method = "method",
	/** Property/field */
	Property = "property",
	/** Field */
	Field = "field",
	/** Variable */
	Variable = "variable",
	/** Constant */
	Constant = "constant",
	/** Type alias */
	Type = "type",
	/** Enum */
	Enum = "enum",
	/** Enum member */
	EnumMember = "enum-member",
	/** Constructor */
	Constructor = "constructor",

	// ===== Declaration Types =====
	/** Export declaration */
	Export = "export",
	/** Import declaration */
	Import = "import",

	// ===== Documentation Types =====
	/** Markdown heading symbol */
	HeadingSymbol = "heading-symbol",
	/** Symbol reference */
	Symbol = "symbol",

	// ===== Error Types =====
	/** File not found */
	FileNotFound = "file_not_found",
	/** Broken reference */
	BrokenReference = "broken_reference",
}

/**
 * Edge Type Enumeration
 * Defines all valid edge types in the graph database
 */
export enum EdgeType {
	// ===== Structural Relationships =====
	/** A contains B (transitive, inheritable) */
	Contains = "contains",
	/** A declares B (inheritable) */
	Declares = "declares",
	/** A belongs to B (transitive) */
	BelongsTo = "belongs_to",

	// ===== Dependency Relationships =====
	/** General dependency (transitive, parent of many) */
	DependsOn = "depends_on",
	/** Import relationship (→ depends_on) */
	Imports = "imports",
	/** Import library (→ depends_on) */
	ImportsLibrary = "imports_library",
	/** Import file (→ depends_on) */
	ImportsFile = "imports_file",
	/** Export relationship */
	ExportsTo = "exports_to",

	// ===== Execution Relationships =====
	/** Function/method call (→ depends_on) */
	Calls = "calls",
	/** Class instantiation (→ depends_on) */
	Instantiates = "instantiates",
	/** Component usage (→ depends_on) */
	Uses = "uses",
	/** Property/variable access (→ depends_on) */
	Accesses = "accesses",

	// ===== Type System Relationships =====
	/** Class inheritance (→ depends_on, inheritable) */
	Extends = "extends",
	/** Interface implementation (→ depends_on, inheritable) */
	Implements = "implements",
	/** Type annotation */
	HasType = "has_type",
	/** Return type */
	Returns = "returns",
	/** Throws exception */
	Throws = "throws",

	// ===== Modification Relationships =====
	/** Method override */
	Overrides = "overrides",
	/** Variable shadowing */
	Shadows = "shadows",
	/** Assignment */
	AssignsTo = "assigns_to",

	// ===== Documentation Relationships =====
	/** Markdown link (transitive) */
	MdLink = "md-link",
	/** Markdown image */
	MdImage = "md-image",
	/** Wiki-style link (transitive) */
	MdWikilink = "md-wikilink",
	/** Symbol reference (transitive) */
	MdSymbolRef = "md-symbol-ref",
	/** File include (transitive) */
	MdInclude = "md-include",
	/** Code block reference */
	MdCodeRef = "md-code-ref",
	/** Internal anchor */
	MdAnchor = "md-anchor",
	/** Hashtag reference */
	MdHashtag = "md-hashtag",
	/** Contains heading (hierarchical) */
	MdContainsHeading = "md-contains-heading",

	// ===== Meta Relationships =====
	/** Annotation/decorator */
	AnnotatedWith = "annotated_with",
	/** General reference (→ depends_on) */
	References = "references",
}

/**
 * Node type categories for grouping
 */
export enum NodeTypeCategory {
	FileResource = "file-resource",
	CodeSymbol = "code-symbol",
	Declaration = "declaration",
	Documentation = "documentation",
	Error = "error",
}

/**
 * Edge type categories for grouping
 */
export enum EdgeTypeCategory {
	Structural = "structural",
	Dependency = "dependency",
	Execution = "execution",
	TypeSystem = "type-system",
	Modification = "modification",
	Documentation = "documentation",
	Meta = "meta",
}

/**
 * Type metadata for additional information
 */
export interface TypeMetadata<T = NodeTypeCategory | EdgeTypeCategory> {
	category: T;
	description: string;
	examples?: string[];
}

/**
 * Node type registry with metadata
 */
export const NODE_TYPE_REGISTRY: Record<NodeType, TypeMetadata<NodeTypeCategory>> = {
	// File & Resource
	[NodeType.File]: {
		category: NodeTypeCategory.FileResource,
		description: "Source code file",
		examples: ["src/services/UserService.ts"],
	},
	[NodeType.ExternalResource]: {
		category: NodeTypeCategory.FileResource,
		description: "External resource (URL, API endpoint)",
		examples: ["https://api.example.com"],
	},
	[NodeType.MissingFile]: {
		category: NodeTypeCategory.Error,
		description: "Missing or broken file reference",
		examples: ["./non-existent.ts"],
	},
	[NodeType.Library]: {
		category: NodeTypeCategory.FileResource,
		description: "External library",
		examples: ["react", "express"],
	},
	[NodeType.Package]: {
		category: NodeTypeCategory.FileResource,
		description: "NPM package",
		examples: ["@types/node"],
	},

	// Code Symbols
	[NodeType.Class]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Class definition",
		examples: ["class UserService", "abstract class BaseController"],
	},
	[NodeType.Interface]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Interface definition",
		examples: ["interface IUser"],
	},
	[NodeType.Function]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Function definition",
		examples: ["function calculateTotal()"],
	},
	[NodeType.Method]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Method definition",
		examples: ["class.login()"],
	},
	[NodeType.Property]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Property/field",
		examples: ["class.userId"],
	},
	[NodeType.Field]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Field",
		examples: ["private id: string"],
	},
	[NodeType.Variable]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Variable",
		examples: ["const user = ..."],
	},
	[NodeType.Constant]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Constant value",
		examples: ["const MAX_SIZE = 100"],
	},
	[NodeType.Type]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Type alias",
		examples: ["type UserId = string"],
	},
	[NodeType.Enum]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Enum definition",
		examples: ["enum Status { Active, Inactive }"],
	},
	[NodeType.EnumMember]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Enum member",
		examples: ["Status.Active"],
	},
	[NodeType.Constructor]: {
		category: NodeTypeCategory.CodeSymbol,
		description: "Constructor",
		examples: ["constructor()"],
	},

	// Declarations
	[NodeType.Export]: {
		category: NodeTypeCategory.Declaration,
		description: "Export declaration",
		examples: ["export { User }"],
	},
	[NodeType.Import]: {
		category: NodeTypeCategory.Declaration,
		description: "Import declaration",
		examples: ["import { User }"],
	},

	// Documentation
	[NodeType.HeadingSymbol]: {
		category: NodeTypeCategory.Documentation,
		description: "Markdown heading symbol",
		examples: ["# Architecture Design"],
	},
	[NodeType.Symbol]: {
		category: NodeTypeCategory.Documentation,
		description: "Symbol reference",
		examples: ["@UserService"],
	},

	// Error
	[NodeType.FileNotFound]: {
		category: NodeTypeCategory.Error,
		description: "File not found error",
		examples: [],
	},
	[NodeType.BrokenReference]: {
		category: NodeTypeCategory.Error,
		description: "Broken reference",
		examples: [],
	},
};

/**
 * Validation functions
 */

/** Check if a string is a valid node type */
export function isValidNodeType(type: string): type is NodeType {
	return Object.values(NodeType).includes(type as NodeType);
}

/** Check if a string is a valid edge type */
export function isValidEdgeType(type: string): type is EdgeType {
	return Object.values(EdgeType).includes(type as EdgeType);
}

/**
 * Get recommended semantic tags for a node type
 * @deprecated Semantic tags should be generated by extraction rules, not pre-defined
 * @returns Empty array - semantic tags are now dynamically generated
 */
export function getRecommendedSemanticTags(nodeType: NodeType): string[] {
	return [];
}

/** Get node type category */
export function getNodeTypeCategory(
	nodeType: NodeType,
): NodeTypeCategory | undefined {
	return NODE_TYPE_REGISTRY[nodeType]?.category;
}

/** Get all node types in a category */
export function getNodeTypesByCategory(
	category: NodeTypeCategory,
): NodeType[] {
	return Object.entries(NODE_TYPE_REGISTRY)
		.filter(([_, metadata]) => metadata.category === category)
		.map(([type]) => type as NodeType);
}

/**
 * Type conversion utilities
 */

/** Convert string to NodeType (with validation) */
export function toNodeType(type: string): NodeType {
	if (!isValidNodeType(type)) {
		throw new Error(`Invalid node type: ${type}`);
	}
	return type;
}

/** Convert string to EdgeType (with validation) */
export function toEdgeType(type: string): EdgeType {
	if (!isValidEdgeType(type)) {
		throw new Error(`Invalid edge type: ${type}`);
	}
	return type;
}

/** Safe conversion with fallback */
export function toNodeTypeSafe(
	type: string,
	fallback: NodeType = NodeType.File,
): NodeType {
	return isValidNodeType(type) ? type : fallback;
}
